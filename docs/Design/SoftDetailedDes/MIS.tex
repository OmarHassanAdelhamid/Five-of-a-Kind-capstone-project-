\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}
\usepackage{graphicx}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\newcommand{\mref}[1]{M\ref{#1}}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
November 13, 2025 & 1.0 & Initial draft by All\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See \href{https://github.com/OmarHassanAdelhamid/Five-of-a-Kind-capstone-project-/blob/main/docs/SRS-Meyer/requirements/SRS.pdf}{SRS} Documentation.

\iffalse
\wss{Also add any additional symbols, abbreviations or acronyms}
\fi

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for \progname{}. \progname{} is a desktop-based CAD enhancement tool that enables researchers and engineers to assign magnetic and material properties to individual voxels within a 3D model. The system allows users to import CAD files (STL format), automatically convert them into voxel grids, and interactively select and modify voxels layer by layer to assign magnetization directions and material assignments. This tool streamlines the magnetization planning process for multi-material 3D printing workflows in research laboratory environments.

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/OmarHassanAdelhamid/Five-of-a-Kind-capstone-project-}

\section{Notation}

\iffalse
\wss{You should describe your notation.  You can use what is below as
  a starting point.}
\fi

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
string & str & a sequence of characters\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
boolean & bool & True or False\\
any type & Any & any data type is acceptable\\
list & list[T] & an ordered collection of objects of type T\\
set & set[T] & an unordered collection of unique objects of type T\\
dictionary & dict[key] = value & data structure containing multiple key-value pairs\\
tuple & tuple[T$_1$, T$_2$, \ldots] or tuple[T] & an ordered collection of values, potentially of different types\\
void & void & indicates no return value\\
current instance & self & a reference to the current instance of a module\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
  \centering
  \caption{Module Hierarchy}\label{TblMH}
  \begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
  \toprule
  \textbf{Level 1} & \textbf{Level 2}\\
  \midrule
  
  {Hardware-Hiding Module} & None \\
  \midrule
  
  \multirow{7}{0.3\textwidth}{Behaviour-Hiding Module} & Input Interpreter Module (M1)\\
  & Voxel Slicing Module (M2)\\
  & Display Partitioning Module (M3)\\
  & Project Manager Module (M4)\\
  & Interaction Controller Module (M5)\\
  & Visualization State Manager Module (M6)\\
  & Model Manager Module (M7)\\
  & History Manager Module (M8)\\
  & Voxel Tracking Module (M9)\\
  & Highlight Manager Module (M10)\\
  & Export Validation Module (M11)\\
  & Export Manager Module (M12)\\
  & Error Diagnostic Handler Module (M13)\\
  \midrule
  
  \multirow{3}{0.3\textwidth}{Software Decision Module} 
  & Model Structure Module (M14)\\
  & Graphics Adapter Module (M15)\\
  & Export Structure Module (M16)\\
  \bottomrule
  
  \end{tabular}
  \end{table}
\newpage
~\newpage

\section{MIS of Input Interpreter (M1)}\label{Module1}

InputInterpreter

\subsection{Module}
The InputInterpreter module is responsible for importing and parsing CAD model files and normalizing them into a consistent internal format that downstream modules can process.

\subsection{Uses}
\begin{itemize}
  \item \texttt{VoxelSlicing} for voxel generation from input CAD file.
  \item \texttt{DisplayPartitioning} to partition the resulting set of voxels.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{SUPPORTED\_FORMATS}: list[str] — supported file types.
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{p{3.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{loadFile} & \texttt{filePath: str} & \texttt{ModelStructure} & \texttt{FileNotFoundError}, \texttt{UnsupportedFileTypeError} \\
\texttt{detectFormat} & \texttt{filePath: str} & \texttt{str} & \texttt{FileNotFoundError} \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None.

\subsubsection{Environment Variables}
\begin{itemize}
  \item \texttt{FILE\_PATH: str} — path to the input file.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
  \item The outer folder of the file path exists, even if the file may not be found.
  \item Data structure of the file conforms to the file format.
\end{itemize}

\subsubsection{Access Routine Semantics}
\texttt{loadFile(filePath: str) -> ModelStructure}
\begin{itemize}
  \item \textbf{Transition:}
  \begin{itemize}
    \item[-] loads file specified at passed file path
    \item[-] passes file to VoxelSlicing
    \item[-] passes resulting voxels to DisplayPartitioning
    \item[-] returns resulting ModelStructure
  \end{itemize}
  \item \textbf{Output:} \texttt{ModelStructure} to be passed to ModelManager
  \item \textbf{Exceptions:} \texttt{FileNotFoundError} if file does not exist; \texttt{UnsupportedFileTypeError} if file type is not in \texttt{SUPPORTED\_FORMATS}
\end{itemize}
\texttt{detectFormat(filePath: str) -> str}
\begin{itemize}
  \item \textbf{Transition:} returns file type via header or extension inspection
  \item \textbf{Output:} \texttt{str} indicating file type
  \item \textbf{Exceptions:} \texttt{FileNotFoundError} if file does not exist
\end{itemize}

\subsubsection{Local Functions}
None.

\section{MIS of Voxel Slicing (M2)}\label{Module2}

VoxelSlicing

\subsection{Module}
The VoxelSlicing module is responsible for converting the geometric model into a structured voxel grid. It divides the 3D model into discrete voxels based on a specified resolution for simulation and visualization.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{DEFAULT\_RESOLUTION: tuple(float, float, float)} — default voxel size in x, y, and z directions.
  \item \texttt{MAX\_LAYERS: int} — maximum number of voxels in the z-dimension.
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{p{3.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{voxelizeModel} & \texttt{model: list[Vector3D]}, \texttt{resolution: tuple(float, float, float)} & \texttt{list[Vector3D]} & None \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None.

\subsubsection{Environment Variables}
None.

\subsubsection{Assumptions}
\begin{itemize}
  \item Input model geometry is well-defined and watertight.
  \item Resolution values are positive real numbers.
  \item The resulting number of voxels does not exceed system memory capacity.
\end{itemize}

\subsubsection{Access Routine Semantics}
\texttt{voxelizeModel(points: list[Vector3D], resolution: tuple(float, float, float)) -> list[Vector3D]}
\begin{itemize}
  \item \textbf{Transition:} produces a set of 3D-coordinates representing voxel centres, given bounding vertexes of the model
  \item \textbf{Output:} \texttt{list[Vector3D]} of voxel centres
  \item \textbf{Exceptions:} None
\end{itemize}

\noindent \textbf{Formalization of \texttt{voxelizeModel}}\\
Adapted from ideas discussed in \textit{An Accurate Method for Voxelizing Polygon Meshes}, \cite{HuangAndYagelAndFilippovAndKurzion1998}\\
\textit{Definitions}
\begin{itemize}
  \item 3D point - a tuple containing three real values, indicating a point in 3D space: t = ($\mathbb{R}$, $\mathbb{R}$, $\mathbb{R}$)
  \item 3D triangle - a tuple containing three 3D points, uniquely defining a triangle: $p = (t_1, t_2, t_3)$
  \item 3D mesh - a set of triangles that form a closed surface, e.g.
  \begin{center}
  $M = \{p_1, p_2, ..., p_n\}$, where
  $(\forall p | p \in M: (\forall t | t \in p: (\exists p_a, p_b | p_a \in M \land p_b \in M$ 
  $\land p_a \neq p_b \land p_b \neq p \land p_a \neq p: t \in p_a \land t \in p_b)))$
  \end{center}
  \item voxel - a 3D cube, defined by its central 3D point: v = t
  \item resolution - $\mathbb{R} > 0$, defines unit length of voxels
  \item voxel grid - set of equally spaced voxels of unit length \textit{resolution} and with centres separated by length \textit{resolution} in each cardinal direction,  thereby completely filling 3D space: $G = {v_1, v_2, ..., v_n}$
\end{itemize}

\noindent \textit{Voxelization Process}
\begin{itemize}
  \item \textit{Generation of surface voxels:} - let $S$ be the union of the three following sets, where all $v \in G$, $v \in G \implies (\exists n_1, n_2, n_3 | n_1, n_2, n_3 \in \mathbb{Z}: (\forall t | t \in v: t = (n_1 \cdot resolution, c_2 \cdot resolution, c_3 \cdot resolution)))$.\\
  $S_v$ - set of all voxels that represent all polygon vertices in M.
  \begin{center}
  $S_v = \{v_1, v_2, ..., v_n\}$, such that\\
  $(\forall p | p \in M: (\forall t | t \in p: (\exists v | v \in S_v: ||v-t||\leq radius) \land (\forall v | v \notin S_v: ||v-t||>radius)))$,\\
  where $radius$ is the radius of a bounding sphere about $t$.
  \end{center}
  $S_e$ - set of all voxels that represent all polygon edges in M.
  \begin{center}
  $S_e = \{v_1, v_2, ..., v_n\}$, such that\\
  $(\forall p | p \in M: (\forall t_1, t_2 | t_1, t_2 \in p \land t_1 \neq t_2: (\forall t_x | t_x = t_1 + \alpha(t_2 - t_1): (\exists v | v \in S_e: ||v-t_x||\leq radius) \land (\forall v | v \notin S_e: ||v-t_x|| > radius))))$,\\
  where $\alpha = [0, 1]$.
  \end{center}
  $S_b$ - set of all voxels that represent all polygon faces in M.
  \begin{center}
  $S_b = \{v_1, v_2, ..., v_n\}$, such that\\
  $(\forall p | p \in M: (\forall t_1, t_2, t_3 | t_1, t_2, t_3 \in p \land t_1 \neq t_2 \land t_2 \neq t_2 \land t_1 \neq t_3: (\exists v | v \in S_b: v \in T^+(t_1, t_2, t_3)) \land (\forall v | v \notin S_b: v \notin T^+(t_1, t_2, t_3))))$,\\
  where $T(a, b, c) = \{a + \alpha(b-a) + \beta(c-a) | \alpha, \beta \geq 0, \alpha + \beta \leq 1\}$,
  $T^+(a, b, c) = \{t + xn | t \in T(a, b, c), -radius \leq x \leq radius, n = \frac{(b-a)\times(c-a)}{||(b-a)\times(c-a)||}\}$
  \end{center}
  \item \textit{Generation of inner voxels:} given $S$, create set $F$ of voxels such that:
  \begin{center}
  $F = \{v | (\forall t | t \in v: (\exists v', v'' | v', v'' \in S \land v' \neq v'' \land v' \neq v \land v'' \neq v: (\exists t^+, t^- | t^+ \in v' \land t^- \in v'': t + \mathbb{R} = t^+ \land t - \mathbb{R} = t^-)))\}$
  \end{center}
  \item Return $S \cup F$.
\end{itemize}

\subsubsection{Local Functions}
None.

\section{MIS of Display Partitioning (M3)}\label{Module3} 

DisplayPartitioning

\subsection{Module}
The DisplayPartitioning module provides core functionality for partitioning the model into distinct display segments.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{MAX\_PARTITIONS: int} — maximum number of partitions that can be created
  \item \texttt{MAX\_VOXELS\_PER\_PARTITION: int} — maximum number of voxels per partition
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{5cm} p{3cm} p{3cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{getPartitions} & \texttt{voxels: list[Vector3D]} & \texttt{dict[str] = partitionItem} & None \\
\texttt{mapVoxels} & \texttt{voxels: list[Voxel], \newline partition: partitionItem} & list[Voxel] & None\\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None.

\subsubsection{Environment Variables}
None.

\subsubsection{Assumptions}
  \begin{itemize}
    \item the \texttt{list[Vector3D]} passed is the complete set of voxels in a given model.
  \end{itemize}
\newpage

\subsubsection{Access Routine Semantics}
\texttt{getPartitions(voxels: list[Vector3D]) -> dict[str] = partitionItem}
\begin{itemize}
  \item \textbf{Transition:} creates set of model partitions based upon passed voxels
  \item \textbf{Output:} \texttt{dict[str] = partitionItem} that maps 2D spatial IDs to \texttt{partitionItem}s
  \item \textbf{Exceptions:} None
\end{itemize}

\noindent \textbf{Formalization of \texttt{getPartitions}}\\
\textit{Definitions}
\begin{itemize}
  \item 3D point - a tuple containing three real values, indicating a point in 3D space: t = ($\mathbb{R}$, $\mathbb{R}$, $\mathbb{R}$)
  \item partition - sector of 3D space that is finite in x and y, but extends infinitely in z and can therefore be defined by a pair of 2D coordinates: p = $((\mathbb{R}, \mathbb{R}), (\mathbb{R}, \mathbb{R}))$. For ease of notation, $p.x$ and $p.y$ refer to a partition's length in the x and y dimensions respectively.
  \item voxel - a 3D cube, defined by its central 3D point: v = t
\end{itemize}
\textit{Partition Definition}\\
Given a set of all voxels $V$, create a minimal set of partitions $P$ such that:
\begin{itemize}
  \item No partitions overlap:
  \begin{center}
  $(\forall p, p' | p, p' \in P: (\forall t, t' | t \in p \land t' \in p': t \neq t'))$
  \end{center}
  \item Partitions are all the same size, and square:
  \begin{center}
  $(\forall p, p' | p, p' \in P: p.x = p'.x \land p.y = p'.y) \land (\forall p | p \in P: p.x = p.y)$
  \end{center}
  \item The set of partitions cover all voxels in the space:
  \begin{center}
  $(\forall v | v \in V: (\exists p | p \in P: v \in P))$
  \end{center}
  \item The number of voxels in one partition is renderable:
  \begin{center}
  $(+v | v \in P: 1) \leq$ MAX\_VOXELS\_PER\_PARTITION
  \end{center}
\end{itemize}
\noindent Assign a unique ID to each partition to allow traversal between partitions and return P.
\\\\
\noindent \texttt{mapVoxels(voxels: list[Voxel], partition: PartitionItem) -> list[Voxel]}
\begin{itemize}
  \item \textbf{Transition:} modifies set of voxels to map them to the passed partition
  \item \textbf{Output:} \texttt{list[Voxel]} - the same list passed in, with partition mappings modified
  \item \textbf{Exceptions:} None
\end{itemize}

\subsubsection{Local Functions}
None.

\section{MIS of Project Manager (M4)}\label{Module4}

ProjectManager

\subsection{Module}

The ProjectManager module manages the creation, initialization, and persistence of project workspaces, handles project metadata storage, and ensures project resources are properly allocated.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ModelManager} to obtain and create the model structure and data representation.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{AUTOSAVE\_INTERVAL: int} - number of seconds between automatic saves 
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{5.2cm} p{5cm} p{3cm} p{3cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{ProjectManager} & \texttt{workspaceRoot: str} & \texttt{self} & \texttt{IOError} \\
\texttt{createNewProject} & \texttt{projectPath: str, \newline config: dict[str] = str} & \texttt{bool} & \texttt{IOError}, \newline \texttt{ValueError} \\
\texttt{loadProject} & \texttt{projectPath: str} & \texttt{bool} & \texttt{IOError}, \newline \texttt{FileNotFoundError} \\
\texttt{saveCurrentProject} & None & \texttt{bool} & \texttt{IOError} \\
\texttt{getCurrentProjectMetadata} & None & \texttt{dict[str] = str} & None \\
\texttt{changeWorkspace} & \texttt{workspaceRoot: str} & \texttt{bool} & \texttt{IOError} \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{currentProjectPath: str} - Path to the current project directory
  \item \texttt{workspaceRoot: str} - Root directory of the current workspace
  \item \texttt{projectMetadata: dict[str] = str} - Dictionary containing metadata of the current project
  \item \texttt{model: ModelManager} - Reference to the model of the current project
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
  \item \texttt{FILE\_SYSTEM}: The file system where the workspaces exist within
  \item \texttt{FILE\_PERMISSIONS}: Permissions the module has (read, write) within the current workspace
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
  \item The file system has sufficient space for project/file creation
  \item Read/write permissions are available for the workspace directory
  \item The provided project paths exist within the current workspace path, or can be created
\end{itemize}

\subsubsection{Access Routine Semantics}
\texttt{ProjectManager(workspaceRoot: str) -> self}
\begin{itemize}
  \item \textbf{Transition:} Creates new ProjectManager object and initializes workspace
  \item \textbf{Output:} \texttt{self} - a reference to itself
  \item \textbf{Exceptions:} \texttt{IOError} if passed workspace path does not exist or cannot be created
\end{itemize}
\texttt{createNewProject(projectPath: str, config: dict[str] = str) -> bool}
\begin{itemize}
  \item \textbf{Transition:} creates a new project at the specified relative path within the current workspace. \texttt{config} notably contains information such as whether the project shall begin with a CAD model or not, and the path of the CAD model to be processed by \texttt{ModelManager}.
  \begin{itemize}
    \item calls \texttt{validateConfig} to verify correctness
    \item calls \texttt{createProjectStructure} to create and initialize project folder
    \item uses \texttt{ModelManager} to create a model, passing path to the CAD model to be converted if needed
    \item calls \texttt{writeMetadataFile} to write initial metadata to the project folder
  \end{itemize}
  \item \textbf{Output:} \texttt{bool} indicating process success
  \item \textbf{Exceptions:} \texttt{IOError} if project path could not be created, \texttt{ValueError} if configuration invalid
\end{itemize}
\texttt{loadProject(projectPath: str) -> bool}
\begin{itemize}
  \item \textbf{Transition:} updates current project path, loads the existing model with ModelManager, and loads metadata file into internal dictionary via \texttt{readMetadataFile}
  \item \textbf{Output:} \texttt{bool} indicating process success
  \item \textbf{Exceptions:} \texttt{IOError} if project path cannot be resolved, \texttt{FileNotFoundError} if any needed file within the project directly does not exist.
\end{itemize}
\texttt{saveCurrentProject() -> bool}
\begin{itemize}
  \item \textbf{Transition:} saves all project components via a call to \texttt{ModelManager} to save the model and a call to \texttt{writeMetadataFile}
  \item \textbf{Output:} \texttt{bool} indicating process success
  \item \textbf{Exceptions:} \texttt{IOError} if any file cannot be saved
\end{itemize}
\texttt{getCurrentProjectMetadata() -> dict[str] = str}
\begin{itemize}
  \item \textbf{Transition:} returns current metadata from related state variable
  \item \textbf{Output:} \texttt{dict[str] = str} the requested metadata
  \item \textbf{Exceptions:} None
\end{itemize}
\texttt{changeWorkspace(workspaceRoot: str) -> bool}
\begin{itemize}
  \item \textbf{Transition:} changes workspace, and saves/closes any open project
  \item \textbf{Output:} \texttt{bool} indicating process success
  \item \textbf{Exceptions:} \texttt{IOError} if new workspace path cannot be resolved
\end{itemize}

\subsubsection{Local Functions}
\texttt{validateConfig(config: dict[str] = str) -> bool}
\begin{itemize}
  \item \textbf{Transition:} validates the configuration dictionary contains required fields
  \item \textbf{Output:} \texttt{bool} indicating validity
  \item \textbf{Exceptions:} None
\end{itemize}
\texttt{createProjectStructure(path: str) -> bool}
\begin{itemize}
  \item \textbf{Transition:} Creates directory and its structure for a new project
  \item \textbf{Output:} \texttt{bool} indicating process success
  \item \textbf{Exceptions:} \texttt{IOError} if structure cannot be created
\end{itemize}
\texttt{readMetadataFile(path: str) -> dict[str] = str}
\begin{itemize}
  \item \textbf{Transition:} reads and parses project metadata from passed file
  \item \textbf{Output:} \texttt{dict[str] = str} - the metadata read
  \item \textbf{Exceptions:} \texttt{FileNotFoundError} if file cannot be found
\end{itemize}
\texttt{writeMetadataFile(metadata: dict[str] = str) -> bool}
\begin{itemize}
  \item \textbf{Transition:} writes project metadata to file
  \item \textbf{Output:} \texttt{bool} indicating process success
  \item \textbf{Exceptions:} \texttt{IOError} if path cannot be resolved
\end{itemize}

\newpage


\section{MIS of Interaction Controller (M5)}\label{Module7} 

InteractionController

\subsection{Module}
The InteractionController module manages the process of raw events from interaction with the UI to associated actions within internal code.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ProjectManager} to handle user intent related to workspace switching, project creation, saving or loading.
  \item \texttt{ModelManager} to handle user intent related to model modification.
  \item \texttt{HistoryManager} to record user's model modifications.
  \item \texttt{ExportManager} to handle user intent related to export.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{UI\_EVENTS: list[UIEvent]} - identifies all supported UI events that can be detected from user interaction.
  \item \texttt{UI\_ACTIONS: : list[UIAction]} - identifies all supported interactions that can be derived from UI events.
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{4cm} p{3cm} p{3cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{interpretEvent} & \texttt{event: UIEvent} & \texttt{list[VisualUpdate]} & None \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{currentView: View} - identifies what view is currently displayed during the interaction.
\end{itemize}

\subsubsection{Environment Variables}
None. 

\subsubsection{Assumptions}
\begin{itemize}
  \item User intent does not exceed the scope of supported actions that can be derived.
  \item There can only be one current active view at a given moment.
  \item \texttt{UIEvent}s passed are always contained within \texttt{UI\_EVENTS}.
  \item Actions are always routed to the relevant internal function.
\end{itemize}

\subsubsection{Access Routine Semantics}
\texttt{interpretEvent(event: UIEvent) -> list[VisualUpdate]}
\begin{itemize}
  \item \textbf{Transition:} translates a \texttt{UIEvent} into a set of \texttt{VisualUpdate}s to be carried out by the \texttt{VisualizationStateManager}, and orchestrates/begins any processes on the model, project, or related to exporting.
  \begin{itemize}
    \item parses \texttt{UIEvent}
    \item if no model/project actions are being taken, returns a list of \texttt{VisualUpdates}
    \item if edits to the model are made, additionally calls \texttt{handleModelUpdate}
    \item if requests to save/load a project or workspace are made, additionally calls \texttt{handleProjectUpdate}
    \item if requests to export model are made, additionally calls \texttt{handleExportUpdate}
  \end{itemize}
  \item \textbf{Output:} \texttt{list[VisualUpdate]} for the \texttt{VisualizationStateManager} to execute
  \item \textbf{Exceptions:} None
\end{itemize}

\subsubsection{Local Functions}
\texttt{handleModelUpdate(action: Action) -> bool}
\begin{itemize}
  \item \textbf{Transition:} translates \texttt{Action} into calls to \texttt{ModelManager} and \texttt{HistoryManager}
  \item \textbf{Output:} \texttt{bool} indicating process success
  \item \textbf{Exceptions:} None
\end{itemize}
\texttt{handleProjectUpdate(action: Action) -> bool}
\begin{itemize}
  \item \textbf{Transition:} translates Action into calls to \texttt{ProjectManager}
  \item \textbf{Output:} \texttt{bool} indicating process success
  \item \textbf{Exceptions:} None
\end{itemize}
\texttt{handleExportUpdate(action: Action) -> bool}
\begin{itemize}
  \item \textbf{Transition:} translates \texttt{Action} into calls to \texttt{ExportManager}
  \item \textbf{Output:} \texttt{bool} indicating process success
  \item \textbf{Exceptions:} None
\end{itemize}

\newpage

\section{MIS of Visualization State Manager (M6)}\label{Module8}

VisualizationManager

% \subsection{Module}
% The VisualizationManager module oversees the creation of UI views while managing subsequent updates to the display state of the specified current UI views on a backend level.
\subsection{Module}
The VisualizationManager module maintains visualization-related state associated with UI views and records visualization update requests corresponding to changes in the underlying model and highlight state.


% \subsection{Uses}
% \begin{itemize}
%   \item \texttt{GraphicsAdapter} for rendering updates visible to user.
%   \item \texttt{VoxelTracking} for specifying the set of voxels affected by a given update.
%   \item \texttt{HighlightManager} for managing change in voxels being highlighted.
%   \item \texttt{InteractionController} for handling user interaction data from the frontend.
%   \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
% \end{itemize}
\subsection{Uses}
\begin{itemize}
  \item \texttt{GraphicsAdapter} for issuing rendering requests corresponding to visualization state updates.
  \item \texttt{HighlightManager} for obtaining semantic highlight state information.
  \item \texttt{InteractionController} as a source of interaction-triggered visualization state change notifications.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}


\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{DEFAULT\_VIEWS}: list[str] — list of identifiers corresponding to the default views generated upon project initialization.
\end{itemize}

% \subsubsection{Exported Access Programs}
% \begin{center}
% \renewcommand{\arraystretch}{1.55}
% \begin{tabular}{p{4cm} p{6cm} p{3cm} p{2.5cm}}
% \hline
% \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
% \texttt{getCurrentView} & None & ViewState & None \\
% \texttt{setView} & state: ViewState & void & None \\
% \texttt{getHighlightState} & None & HighlightState & None \\
% \texttt{updateModel} & voxelCoords: list[VoxelCoord], \newline updateType: ModelUpdateType & void & None \\
% \texttt{updateHighlight} & semanticKey: str & void & None \\
% \hline
% \end{tabular}
% \end{center}
\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{6cm} p{3cm} p{2.5cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{getCurrentView} & None & str & None \\
\texttt{setView} & state: str & void & None \\
\hline
\end{tabular}
\end{center}


% \subsection{Semantics}

% \subsubsection{State Variables}
% \begin{itemize}
%   \item \texttt{currentView}: str — identifies which UI view is currently shown to the user.
%   \item \texttt{viewStatus}: dict[str] = ViewItem — stores all data encapsulated within a UI view.
%   \item \texttt{updateBundle}: dict[str] = UpdateItem — stores all data needed to update a UI view upon a render request.
%   \item \texttt{pendingUpdates}: list[UpdateKey] — updates waiting to be processed in rendering.
%   \item \texttt{renderStatus}: bool — records the success status of the rendering process.
%   \item \texttt{supportedViews}: list[str] — identifiers corresponding to all available project views.
% \end{itemize}
\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{currentView}: str — identifies which UI view is currently shown to the user.
  \item \texttt{viewStatus}: dict[str] = ViewItem — stores all data encapsulated within a UI view.
  \item \texttt{updateBundle}: dict[str] = UpdateItem — stores all data needed to describe a visualization update request.
  \item \texttt{pendingUpdates}: list[UpdateKey] — visualization update requests waiting to be forwarded for rendering.
  \item \texttt{renderStatus}: bool — records the status of the most recent rendering request.
  \item \texttt{supportedViews}: list[str] — identifiers corresponding to all available project views.
\end{itemize}


% \subsubsection{Environment Variables}
% None

% \subsubsection{Assumptions}
% \begin{itemize}
%   \item Partitions are initialized.
%   \item ViewItem is properly formatted in accordance with ViewItem specification.
%   \item UpdateItem is properly formatted in accordance with UpdateItem specification.
%   \item \texttt{currentView}, \texttt{ViewState}, and \texttt{DEFAULT\_VIEWS} are elements of \texttt{supportedViews}.
% \end{itemize}
\subsubsection{Assumptions}
\begin{itemize}
  \item Visualization state references only initialized and valid view identifiers.
  \item ViewItem is properly formatted in accordance with ViewItem specification.
  \item UpdateItem is properly formatted in accordance with UpdateItem specification.
  \item \texttt{currentView}, \texttt{ViewState}, and \texttt{DEFAULT\_VIEWS} are elements of \texttt{supportedViews}.
\end{itemize}

\subsubsection{Access Routine Semantics}

getCurrentView() $\rightarrow$ str
\begin{itemize}
  \item Transition: retrieves the identifier of the currently active visualization view.
  \item Output: str representing the current view identifier.
  \item Exceptions: None.
\end{itemize}

setView(state: str) $\rightarrow$ void
\begin{itemize}
  \item Transition: updates the current visualization view to the specified view identifier.
  \item Output: None.
  \item Exceptions: None.
\end{itemize}


\section{MIS of Model Manager (M7)}\label{Module9}

ModelManager

\subsection{Module}
The ModelManager module manages and mutates the voxel-based 3D model. It provides operations to add, remove, and modify voxels, update material and magnetization properties, and explicitly persist model state through save operations.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ModelStructure} to access and update the model’s internal data representation.
  \item \texttt{VoxelTracking} to track changes made to voxel data.

  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{MAX\_VOXEL\_COUNT}: int — maximum allowed voxel entries per project.
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{p{4cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{addVoxel} & coord: Any, material: Any, mag: Any & void & InvalidInputError \\
\texttt{removeVoxel} & coord: Any & void & NotFoundError \\
\texttt{modifyVoxel} & coord: Any, newData: Any & void & NotFoundError \\
\texttt{saveModel} & None & bool & IOError \\
\texttt{forceSave} & None & bool & IOError \\
\texttt{loadModel} & filePath: str & bool & DeserializationError \\
\bottomrule
\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{voxelGrid}: VoxelGrid — stores all voxel elements and layer mapping.
  \item \texttt{metadata}: dict — contains file name, author, timestamp, etc.
  \item \texttt{unsavedChanges}: bool — true if edits have occurred since last save.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
  \item \texttt{SAVE\_PATH}: str — default save location for serialized project data.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
  \item Voxel coordinates fall within the defined model boundaries.
  \item Data supplied for voxel modifications are valid according to schema.
  \item Save operations are explicitly invoked and do not interrupt ongoing edits.
\end{itemize}

\subsubsection{Access Routine Semantics}

addVoxel(coord: Any, material: Any, mag: Any) $\rightarrow$ void
\begin{itemize}
  \item Transition: inserts a new voxel into the model at the specified coordinate with the given material and magnetization properties.
  \item Output: None.
  \item Exceptions: InvalidInputError if the provided data is invalid.
\end{itemize}

removeVoxel(coord: Any) $\rightarrow$ void
\begin{itemize}
  \item Transition: removes the voxel at the specified coordinate from the model.
  \item Output: None.
  \item Exceptions: NotFoundError if the voxel does not exist.
\end{itemize}

modifyVoxel(coord: Any, newData: Any) $\rightarrow$ void
\begin{itemize}
  \item Transition: updates the properties of the voxel at the specified coordinate using the provided data.
  \item Output: None.
  \item Exceptions: NotFoundError if the voxel does not exist.
\end{itemize}

saveModel() $\rightarrow$ bool
\begin{itemize}
  \item Transition: serializes and persists the current model state to storage.
  \item Output: bool indicating whether the save operation was successful.
  \item Exceptions: IOError if the save operation fails.
\end{itemize}

forceSave() $\rightarrow$ bool
\begin{itemize}
  \item Transition: immediately serializes and persists the current model state, regardless of unsaved change state.
  \item Output: bool indicating whether the save operation was successful.
  \item Exceptions: IOError if the save operation fails.
\end{itemize}

loadModel(filePath: str) $\rightarrow$ bool
\begin{itemize}
  \item Transition: loads and deserializes model data from the specified file path, replacing the current model state.
  \item Output: bool indicating whether the load operation was successful.
  \item Exceptions: DeserializationError if loading fails due to invalid data.
\end{itemize}

% ModelManager

% \subsection{Module}
% The ModelManager module oversees the management and manipulation of the voxel-based 3D model. It provides APIs to add, remove, or modify voxels, update magnetization/material properties, and synchronize changes with autosave and history tracking modules.

% \subsection{Uses}
% \begin{itemize}
%   \item \texttt{ModelStructure} to get the model structure and data representation.
%   \item \texttt{VisualizationManager} to get the current view state.
%   \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
% \end{itemize}

% \subsection{Syntax}

% \subsubsection{Exported Constants}
% \begin{itemize}
%   \item \texttt{MAX\_VOXEL\_COUNT}: int — maximum allowed voxel entries per project.
%   \item \texttt{AUTOSAVE\_INTERVAL\_S}: float — time threshold (in seconds) before triggering autosave.
% \end{itemize}

% \subsubsection{Exported Access Programs}
% \begin{center}
% \renewcommand{\arraystretch}{1.3}
% \begin{tabular}{p{4cm} p{4.5cm} p{3.5cm} p{3.5cm}}
% \toprule
% \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
% \midrule
% \texttt{addVoxel} & coord: VoxelCoord, material: MaterialType, mag: Vector3 & void & InvalidInputError \\
% \texttt{removeVoxel} & coord: VoxelCoord & void & NotFoundError \\
% \texttt{modifyVoxel} & coord: VoxelCoord, newData: VoxelData & void & NotFoundError \\
% \texttt{saveModel} & None & bool & IOerror \\
% \texttt{loadModel} & filePath: str & bool & DeserializationError \\
% \bottomrule
% \end{tabular}
% \end{center}

% \subsection{Semantics}

% \subsubsection{State Variables}
% \begin{itemize}
%   \item \texttt{voxelGrid}: VoxelGrid — stores all voxel elements and layer mapping.
%   \item \texttt{metadata}: dict — contains file name, author, timestamp, etc.
%   \item \texttt{autosaveTimer}: float — time since last autosave.
%   \item \texttt{unsavedChanges}: bool — true if edits have occurred since last save.
% \end{itemize}

% \subsubsection{Environment Variables}
% \begin{itemize}
%   \item \texttt{SAVE\_PATH}: str — default save location for serialized project data.
% \end{itemize}

% \subsubsection{Assumptions}
% \begin{itemize}
%   \item Voxel coordinates fall within the defined model boundaries.
%   \item Data supplied for voxel modifications are valid according to schema.
%   \item Autosave operations will not interrupt ongoing edits.
% \end{itemize}

% \iffalse
% \subsubsection{Access Routine Semantics}
% \begin{itemize}
%   \item \texttt{addVoxel(coord, material, mag)}: Adds new voxel entry at specified coordinate.
%   \[
%   G' = G \cup \{v = (coord, material, mag)\}
%   \]
%   Triggers \texttt{HistoryManager.push}($\Delta M$).
  
%   \item \texttt{removeVoxel(coord)}: Deletes voxel from grid and logs change.
%   \[
%   G' = G \setminus \{v \mid v.coord = coord\}
%   \]

%   \item \texttt{modifyVoxel(coord, newData)}: Updates voxel’s attributes.
%   \[
%   v' = newData \text{ if } v.coord = coord
%   \]

%   \item \texttt{saveModel()}: Serializes model and writes to file via \texttt{SerializationManager}.
%   \item \texttt{loadModel(filePath)}: Deserializes project data from storage and rebuilds voxel grid.
% \end{itemize}

% \subsubsection{Exceptions}
% \begin{itemize}
%   \item \texttt{InvalidInputError} — malformed coordinate or data type.
%   \item \texttt{NotFoundError} — voxel coordinate not present in grid.
%   \item \texttt{IOerror} — failure during save operation.
%   \item \texttt{DeserializationError} — corrupted or incompatible input file.
% \end{itemize}
% \fi

\section{MIS of History Manager (M8)}\label{Module10}

HistoryManager

\subsection{Module}
The HistoryManager module maintains the complete change history of the 3D voxel model. It allows undoing and redoing edits by tracking incremental changes (referred to here as deltas) triggered by user modification.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{MAX\_HISTORY\_SIZE}: int — maximum number of undo states stored.
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{p{4cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{recordChange} & \texttt{delta: modelDelta} & None & None \\
\texttt{undoRequest} & None & \texttt{delta: modelDelta} & \texttt{EmptyHistoryError} \\
\texttt{redoRequest} & None & \texttt{delta: modelDelta} & \texttt{EmptyHistoryError} \\
\texttt{clearHistory} & None & None & None \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{historyStack: list[modelDelta]} - sequence of changes to the model.
  \item \texttt{redoStack: list[modelDelta]} - sequence of undone model states available for redo.
\end{itemize}

\subsubsection{Environment Variables}
None.

\subsubsection{Assumptions}
\begin{itemize}
  \item Changes are discrete and atomic.
  \item No new change is made while undo or redo is in progress.
  \item The number of stored changes does not exceed \texttt{MAX\_HISTORY\_SIZE}; when another change is added, the oldest change is lost.
  \item \texttt{clearHistory} is called when a new project is created or switched to (changes are not saved with projects).
\end{itemize}

\subsubsection{Access Routine Semantics}
\texttt{recordChange(delta: modelDelta) -> None}
\begin{itemize}
  \item \textbf{Transition:} adds passed change to \texttt{historyStack}, and calls \texttt{clearRedo()}
  \item \textbf{Output:} None
  \item \textbf{Exceptions:} None
\end{itemize}
\texttt{undoRequest() -> modelDelta}
\begin{itemize}
  \item \textbf{Transition:} moves most recent \texttt{modelDelta} on \texttt{historyStack} to \texttt{redoStack} and returns it
  \item \textbf{Output:} \texttt{modelDelta} - most recent change
  \item \textbf{Exceptions:} \texttt{EmptyHistoryError} if \texttt{historyStack} is empty
\end{itemize}
\texttt{redoRequest() -> modelDelta}
\begin{itemize}
  \item \textbf{Transition:} moves most recent \texttt{modelDelta} on \texttt{redoStack} to \texttt{historyStack} and returns It
  \item \textbf{Output:} \texttt{modelDelta} - most recent change
  \item \textbf{Exceptions:} \texttt{EmptyHistoryError} if \texttt{redoStack} is empty
\end{itemize}
\texttt{clearHistory() -> None}
\begin{itemize}
  \item \textbf{Transition:} makes both \texttt{historyStack} and \texttt{redoStack} empty
  \item \textbf{Output:} None
  \item \textbf{Exceptions:} None
\end{itemize}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{figures/HistoryManagerFSM.pdf}
  \caption{Finite State Machine for HistoryManager.}
  \label{fig:hmfsm}
\end{figure}

\subsubsection{Local Functions}
\texttt{clearRedo() -> None}
\begin{itemize}
  \item \textbf{Transition:} makes only \texttt{redoStack} empty
  \item \textbf{Output:} None
  \item \textbf{Exceptions:} None
\end{itemize}

\section{MIS of Voxel Tracking (M9)}\label{Module12}

VoxelTracking

\subsection{Module}
The VoxelTracking module interprets the voxel data structure to locate and track voxels that satisfy particular property criteria, such as selection state, material type, or user-defined rules. It provides read-only access to voxel query results without modifying model state or interpreting user interaction.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ModelStructure} to get the model structure and data representation.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{MAX\_QUERY\_RESULTS}: int — maximum number of voxels returned in a single query result.
  \item \texttt{SUPPORTED\_PROPERTIES}: list[str] — list of property names that can be queried (e.g., "material", "magnetization", "selected", "layer").
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{p{4cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{queryByMaterial} & materialType: Any & list[Any] & InvalidMaterialError \\
\texttt{queryBySelection} & isSelected: bool & list[Any] & None \\
\texttt{queryByRegion} & bounds: Any & list[Any] & InvalidBoundsError \\
\texttt{queryByLayer} & layerZ: Z & list[Any] & IndexError \\
\texttt{queryByProperty} & propertyName: str, value: Any & list[Any] & InvalidPropertyError \\
\texttt{getVoxelProperties} & coord: Any & dict[str] = Any & NotFoundError \\
\bottomrule
\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{queryCache}: dict[str] = list[VoxelCoord] — cached results of recent read-only queries for performance optimization.
  \item \texttt{activeSelections}: set[VoxelCoord] — cached snapshot of selection state derived from model state.
\end{itemize}

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
\begin{itemize}
  \item Voxel coordinates provided in queries are within valid grid boundaries.
  \item Property names used in queries match those defined in \texttt{SUPPORTED\_PROPERTIES}.
  \item The voxel grid structure remains consistent during query operations.
\end{itemize}

\subsubsection{Access Routine Semantics}

queryByMaterial(materialType: Any) $\rightarrow$ list[Any]
\begin{itemize}
  \item Transition: retrieves all voxel identifiers whose material property matches the specified material type.
  \item Output: list[Any] containing voxel identifiers.
  \item Exceptions: InvalidMaterialError if the material type is not recognized.
\end{itemize}

queryBySelection(isSelected: bool) $\rightarrow$ list[Any]
\begin{itemize}
  \item Transition: retrieves all voxel identifiers that match the specified selection state.
  \item Output: list[Any] containing voxel identifiers.
  \item Exceptions: None.
\end{itemize}

queryByRegion(bounds: Any) $\rightarrow$ list[Any]
\begin{itemize}
  \item Transition: retrieves all voxel identifiers that lie within the specified spatial bounds.
  \item Output: list[Any] containing voxel identifiers.
  \item Exceptions: InvalidBoundsError if the bounds are invalid.
\end{itemize}

queryByLayer(layerZ: Z) $\rightarrow$ list[Any]
\begin{itemize}
  \item Transition: retrieves all voxel identifiers that belong to the specified layer.
  \item Output: list[Any] containing voxel identifiers.
  \item Exceptions: IndexError if the layer index is out of range.
\end{itemize}

queryByProperty(propertyName: str, value: Any) $\rightarrow$ list[Any]
\begin{itemize}
  \item Transition: retrieves all voxel identifiers whose specified property matches the given value.
  \item Output: list[Any] containing voxel identifiers.
  \item Exceptions: InvalidPropertyError if the property name is not supported.
\end{itemize}

getVoxelProperties(coord: Any) $\rightarrow$ dict[str] = Any
\begin{itemize}
  \item Transition: retrieves all stored properties associated with the specified voxel identifier.
  \item Output: dict[str] = Any containing voxel properties.
  \item Exceptions: NotFoundError if the voxel identifier does not exist.
\end{itemize}



% VoxelTracking

% \subsection{Module}
% The VoxelTracking module interprets the voxel data structure to locate and track voxels that satisfy particular property criteria, such as selection state, material type, or user-defined rules. It efficiently identifies and accesses relevant voxels to determine which voxels are currently subject to operations like highlighting, selection, or further processing.

% \subsection{Uses}
% \begin{itemize}
%   \item \texttt{ModelStructure} to get the model structure and data representation.
%   \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
% \end{itemize}

% \subsection{Syntax}

% \subsubsection{Exported Constants}
% \begin{itemize}
%   \item \texttt{MAX\_QUERY\_RESULTS}: int — maximum number of voxels returned in a single query result.
%   \item \texttt{SUPPORTED\_PROPERTIES}: list[str] — list of property names that can be queried (e.g., "material", "magnetization", "selected", "layer").
% \end{itemize}

% \subsubsection{Exported Access Programs}
% \begin{center}
% \renewcommand{\arraystretch}{1.3}
% \begin{tabular}{p{4cm} p{4.5cm} p{3.5cm} p{3.5cm}}
% \toprule
% \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
% \midrule
% \texttt{queryByMaterial} & materialType: MaterialType & list[VoxelCoord] & InvalidMaterialError \\
% \texttt{queryBySelection} & isSelected: bool & list[VoxelCoord] & None \\
% \texttt{queryByRegion} & bounds: BoundingBox & list[VoxelCoord] & InvalidBoundsError \\
% \texttt{queryByLayer} & layerZ: int & list[VoxelCoord] & IndexError \\
% \texttt{queryByProperty} & propertyName: str, value: Any & list[VoxelCoord] & InvalidPropertyError \\
% \texttt{getVoxelProperties} & coord: VoxelCoord & VoxelProperties & NotFoundError \\
% \bottomrule
% \end{tabular}
% \end{center}

% \subsection{Semantics}

% \subsubsection{State Variables}
% \begin{itemize}
%   \item \texttt{queryCache}: dict[str] = list[VoxelCoord] — cached results of recent queries for performance optimization.
%   \item \texttt{activeSelections}: set[VoxelCoord] — set of currently selected voxel coordinates.
% \end{itemize}

% \subsubsection{Environment Variables}
% None

% \subsubsection{Assumptions}
% \begin{itemize}
%   \item Voxel coordinates provided in queries are within valid grid boundaries.
%   \item Property names used in queries match those defined in \texttt{SUPPORTED\_PROPERTIES}.
%   \item The voxel grid structure remains consistent during query operations.
% \end{itemize}

% \iffalse
% \subsubsection{Access Routine Semantics}
% \begin{itemize}
%   \item \texttt{queryByMaterial(materialType)}: Returns all voxel coordinates that have the specified material type.
%   \[
%   R = \{v.coord \mid v \in G, v.material = materialType\}
%   \]
  
%   \item \texttt{queryBySelection(isSelected)}: Returns all voxel coordinates that match the selection state.
%   \[
%   R = \begin{cases}
%   activeSelections & \text{if } isSelected = true\\
%   \{v.coord \mid v \in G, v.coord \notin activeSelections\} & \text{if } isSelected = false
%   \end{cases}
%   \]
  
%   \item \texttt{queryByRegion(bounds)}: Returns all voxel coordinates within the specified bounding box.
%   \[
%   R = \{v.coord = (x,y,z) \mid v \in G, bounds.min \leq (x,y,z) \leq bounds.max\}
%   \]
  
%   \item \texttt{queryByLayer(layerZ)}: Returns all voxel coordinates in the specified layer.
%   \[
%   R = \{v.coord = (x,y,z) \mid v \in G, z = layerZ\}
%   \]
  
%   \item \texttt{queryByProperty(propertyName, value)}: Returns all voxel coordinates where the specified property matches the given value.
%   \[
%   R = \{v.coord \mid v \in G, v[propertyName] = value\}
%   \]
  
%   \item \texttt{getVoxelProperties(coord)}: Retrieves all properties of the voxel at the specified coordinate.
%   \[
%   P = \{property: value \mid property \in SUPPORTED\_PROPERTIES, value = v[property]\}
%   \]
%   where $v$ is the voxel at coordinate $coord$.
% \end{itemize}

% \subsubsection{Exceptions}
% \begin{itemize}
%   \item \texttt{InvalidMaterialError} — material type not recognized or not in valid material set.
%   \item \texttt{InvalidBoundsError} — bounding box is invalid (e.g., min > max) or out of grid boundaries.
%   \item \texttt{IndexError} — layer index is out of range.
%   \item \texttt{InvalidPropertyError} — property name not in \texttt{SUPPORTED\_PROPERTIES}.
%   \item \texttt{NotFoundError} — voxel coordinate not present in grid.
% \end{itemize}
% \fi
% \newpage

\section{MIS of Highlight Manager (M10)}\label{Module13} 

HighlightManager

\subsection{Module}
The HighlightManager module manages the voxel highlights in accordance with visual semantic meaning.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
  \item \texttt{DEFAULT\_HIGHLIGHT\_MAP}: dict[str] = str — mapping from semantic keys to their default highlight colours.
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{5cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline

\texttt{getHighlight} &
semanticKey: str &
ColourValue &
None \\

\texttt{editPalette} &
semanticKey: str, \newline
newColour: ColourValue &
void &
None \\

\texttt{setHighlight} &
semanticKey: str &
void &
None \\

\texttt{resetPalette} &
None &
void &
None \\

\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{highlightColourMap}: dict[str] = str — current mapping from semantic keys to active highlight colours.
\end{itemize}

\subsubsection{Environment Variables}
None


\subsubsection{Assumptions}
\begin{itemize}
  \item Semantic keys must correspond to valid entries maintained by the TrackingManager.
  \item Colour values are valid colour representations.
\end{itemize}

\subsubsection{Access Routine Semantics}

getHighlight(semanticKey: str) $\rightarrow$ str
\begin{itemize}
  \item Transition: retrieves the highlight colour associated with the specified semantic key.
  \item Output: str representing the highlight colour.
  \item Exceptions: None.
\end{itemize}

editPalette(semanticKey: str, newColour: str) $\rightarrow$ void
\begin{itemize}
  \item Transition: updates the highlight colour mapping for the specified semantic key.
  \item Output: None.
  \item Exceptions: None.
\end{itemize}

setHighlight(semanticKey: str) $\rightarrow$ void
\begin{itemize}
  \item Transition: applies the highlight associated with the specified semantic key to relevant voxels.
  \item Output: None.
  \item Exceptions: None.
\end{itemize}

resetPalette() $\rightarrow$ void
\begin{itemize}
  \item Transition: restores all highlight colours to their default values.
  \item Output: None.
  \item Exceptions: None.
\end{itemize}

\newpage

\section{MIS of Export Validation (M11)}\label{Module14}

ExportValidation

\subsection{Module}

The ExportValidation module validates export readiness by checking export file format requirements, verifying completeness of voxel properties (material and magnetization), and ensuring all export constraints are met. 

\subsection{Uses}
\begin{itemize}
  
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
\item \texttt{MAX\_VOXELS}: $\mathbb{Z}$ = 13996800000 - Maximum number of voxels allowed
\item \texttt{MAX\_LAYERS}: $\mathbb{Z}$ = 518400 - Maximum number of layers allowed
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{5cm} p{5cm} p{3.5cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{validateExportReadiness} & model: Any & Any & None \\
\texttt{checkPrinterCompatibility} & model: Any & bool & None \\
\texttt{checkPropertyCompleteness} & model: Any & list[str] & None \\
\texttt{validateFileFormat} & filePath: str & bool & IOError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None

\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

\begin{itemize}
\item The model structure provided is valid and properly initialized
\item All voxels in the model have consistent property structures
\item File paths provided are accessible and readable
\end{itemize}

\subsubsection{Access Routine Semantics}

validateExportReadiness(model: Any) $\rightarrow$ Any
\begin{itemize}
  \item Transition: evaluates whether the provided model satisfies all export constraints, including size limits, property completeness, and format requirements.
  \item Output: Any representing the result of export readiness validation.
  \item Exceptions: None.
\end{itemize}

checkPrinterCompatibility(model: Any) $\rightarrow$ bool
\begin{itemize}
  \item Transition: checks whether the provided model satisfies printer-specific constraints and limitations.
  \item Output: bool indicating printer compatibility.
  \item Exceptions: None.
\end{itemize}

checkPropertyCompleteness(model: Any) $\rightarrow$ list[str]
\begin{itemize}
  \item Transition: verifies that all required voxel properties are present and returns identifiers of any missing properties.
  \item Output: list[str] containing names of missing properties, if any.
  \item Exceptions: None.
\end{itemize}

validateFileFormat(filePath: str) $\rightarrow$ bool
\begin{itemize}
  \item Transition: validates that the export file format at the specified file path meets supported format requirements.
  \item Output: bool indicating whether the file format is valid.
  \item Exceptions: IOError if the file cannot be accessed.
\end{itemize}


\subsubsection{Local Functions}

\begin{itemize}
\item \texttt{countVoxels(model: ModelStructure) -> $\mathbb{Z}$}: Counts the total number of voxels in the model
\item \texttt{countLayers(model: ModelStructure) -> $\mathbb{Z}$}: Counts the total number of layers in the model
\item \texttt{checkPrinterSpecs(model: ModelStructure) -> bool}: Validates model against printer-specific constraints
\end{itemize}

\newpage

\section{MIS of Export Manager (M12)}\label{Module15} 

ExportManager

\subsection{Module}

The ExportManager module coordinates the export process, transforms internal model data into export-compatible formats, and serializes project data including voxel grids, metadata, material properties, and magnetization information according to export specifications.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ModelStructure} to obtain the model structure and data representation.
  \item \texttt{ExportValidation} to validate export validity.
  \item \texttt{ExportStructure} to define the export data structure format.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}


\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
\item \texttt{DEFAULT\_EXPORT\_FORMAT}: str = "CSV" - Default export file format
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{6cm} p{5cm} p{2cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{ExportManager} & - & self & - \\
\texttt{exportProject} & model: ModelStructure, \newline exportPath: str, \newline format: str & None &  IOError, \newline ValueError \\
\texttt{transformToExportFormat} & model: ModelStructure, \newline format: str & ExportData & - \\
\texttt{serializeData} & data: ExportData, \newline format: str & str & ValueError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
\item \texttt{exportFormat}: str - Current export format being used
\item \texttt{exportConfig}: dict - Configuration settings for export operations
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
\item \texttt{FILE\_SYSTEM}: The file system where export files are written
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
\item The model structure provided has been validated for export readiness
\item The export path directory exists or can be created
\item Write permissions are available for the export directory
\item The export format is supported
\end{itemize}

\subsubsection{Access Routine Semantics}

ExportManager() $\rightarrow$ self
\begin{itemize}
  \item Transition: initializes the export manager with default configuration values.
  \item Output: self.
  \item Exceptions: None.
\end{itemize}

exportProject(model: Any, exportPath: str, format: str) $\rightarrow$ void
\begin{itemize}
  \item Transition: coordinates the export process by validating the model, transforming model data into the specified export format, and writing the serialized data to the given export path.
  \item Output: None.
  \item Exceptions: IOError if writing fails; ValueError if the export format is invalid.
\end{itemize}

transformToExportFormat(model: Any, format: str) $\rightarrow$ Any
\begin{itemize}
  \item Transition: transforms the provided model data into an intermediate export-compatible data representation based on the specified format.
  \item Output: Any representing export-formatted data.
  \item Exceptions: None.
\end{itemize}

serializeData(data: Any, format: str) $\rightarrow$ str
\begin{itemize}
  \item Transition: serializes the provided export data into a string representation according to the specified format.
  \item Output: str representing serialized export data.
  \item Exceptions: ValueError if serialization fails due to unsupported format.
\end{itemize}


\subsubsection{Local Functions}

\begin{itemize}
\item \texttt{groupVoxelsByLayer(model: ModelStructure) -> dict}: Groups voxels by their layer Z-coordinate
\item \texttt{encodeCSV(exportData: ExportData) -> str}: Encodes export data into CSV format string
\item \texttt{validateExportPath(path: str) -> bool}: Validates that the export path is writable
\item \texttt{creatExportDirectory(path: str) -> None}: Creates the export directory if it does not exist
\end{itemize}

\newpage

\section{MIS of Error Diagnostic Handler (M13)}\label{Module16}

ErrorDiagnosticHandler

\subsection{Module}

The ErrorDiagnosticHandler module detects, diagnoses, and handles errors that occur during model operations, graphics rendering, and file interactions. It provides error classification, logging, and recovery mechanisms to ensure system stability and user feedback.

\subsection{Uses}

None

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
\item \texttt{ERROR\_MODEL\_UNRESPONSIVE}: str = "MODEL\_UNRESPONSIVE" - Error code for unresponsive model
\item \texttt{ERROR\_GRAPHICS\_UPDATE}: str = "GRAPHICS\_UPDATE\_FAILURE" - Error code for graphics update failure
\item \texttt{ERROR\_FILE\_ISSUE}: str = "FILE\_OPERATION\_ERROR" - Error code for file operation errors
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{5cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{detectError} & errorContext: dict & ErrorDiagnostic & - \\
\texttt{classifyError} & errorCode: str, \newline errorContext: dict & ErrorType & - \\
\texttt{logError} & errorDiagnostic: ErrorDiagnostic & None & IOError \\
\texttt{handleErrorRecovery}& errorDiagnostic: ErrorDiagnostic & RecoveryAction & - \\
\texttt{getErrorSource} & errorDiagnostic: ErrorDiagnostic & str & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{errorLog}: list[ErrorDiagnostic] - History of detected errors
\item \texttt{errorPatterns}: dict - Patterns for error classification
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
\item \texttt{LOG\_FILE}: File system location for error logging
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
\item Error context dictionaries contain sufficient information for diagnosis
\item Log file location is writable
\item Error codes follow the defined constants
\end{itemize}

\subsubsection{Access Routine Semantics}

detectError(errorContext: dict[str] = Any) $\rightarrow$ Any
\begin{itemize}
  \item Transition: analyzes the provided error context to detect and generate an error diagnostic record.
  \item Output: Any representing the detected error diagnostic.
  \item Exceptions: None.
\end{itemize}

classifyError(errorCode: str, errorContext: dict[str] = Any) $\rightarrow$ Any
\begin{itemize}
  \item Transition: classifies the error based on the provided error code and contextual information.
  \item Output: Any representing the determined error classification.
  \item Exceptions: None.
\end{itemize}

logError(errorDiagnostic: Any) $\rightarrow$ void
\begin{itemize}
  \item Transition: records the provided error diagnostic information in persistent error logs.
  \item Output: None.
  \item Exceptions: IOError if the error log cannot be written.
\end{itemize}

handleErrorRecovery(errorDiagnostic: Any) $\rightarrow$ Any
\begin{itemize}
  \item Transition: determines and returns an appropriate recovery action based on the provided error diagnostic.
  \item Output: Any representing the recovery action.
  \item Exceptions: None.
\end{itemize}

getErrorSource(errorDiagnostic: Any) $\rightarrow$ str
\begin{itemize}
  \item Transition: identifies the source component associated with the provided error diagnostic.
  \item Output: str indicating the source of the error.
  \item Exceptions: None.
\end{itemize}


\subsubsection{Local Functions}

\begin{itemize}
\item \texttt{analyzeErrorPattern(errorContext: dict) -> str}: Analyzes error context to identify error patterns
\item \texttt{determineErrorSource(context: dict) -> str}: Determines the source component from error context
\item \texttt{formatErrorMessage(errorCode: str, context: dict) -> str}: Formats a human-readable error message
\item \texttt{suggestRecoverySteps(errorType: ErrorType) -> list[str]}: Generates recovery step suggestions based on error type
\end{itemize}

\newpage


\section{MIS of Model Structure (M14)}\label{Module17}

ModelStructure

\subsection{Module}

The ModelStructure module stores and organizes all voxel and layer data for the model, including per-voxel properties, metadata, and structural dimensions.

\subsection{Uses}
\begin{itemize}
  \item \texttt{DisplayPartitioning} to remake partitions should the need arise.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{VOXEL\_SIZE\_X}: float - Voxel size in X dimension
  \item \texttt{VOXEL\_SIZE\_Y}: float - Voxel size in Y dimension
  \item \texttt{VOXEL\_SIZE\_Z}: float - Voxel size in Z dimension
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{5cm} p{3cm} p{3cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{ModelStructure} & \texttt{voxelPositions: list[Vector3D]} & \texttt{self} & None \\
\texttt{getLayer} & \texttt{z: int} & \texttt{list[Vector3D]} & \texttt{IndexError} \\
\texttt{getProperty} & \texttt{index: tuple(int, int, int)}, \newline \texttt{property: propertyName} & \texttt{Any} & \texttt{IndexError}, \newline \texttt{KeyError} \\
\texttt{setProperty} & \texttt{index: tuple(int, int, int)}, \newline \texttt{property: propertyName}, \newline \texttt{value: Any} & None & \texttt{IndexError}, \newline \texttt{ValueError} \\
\texttt{hasProperty} & \texttt{index: tuple(int, int, int), property: propertyName} & \texttt{bool} & \texttt{IndexError} \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{voxelGrid: array3D[Voxel]} - Three-dimensional grid storing voxel data
  \item \texttt{partitions: list[partitionItem]} - List of all current partitions 
\end{itemize}

\subsubsection{Environment Variables}
None.

\subsubsection{Assumptions}
\begin{itemize}
  \item Property names are consistent across voxels
  \item Property values conform to expected formats
  \item Passed partitions are validated and do not overlap
  \item All passed voxel centres are contained within exactly one partition and all partitions cover all voxels
\end{itemize}

\subsubsection{Access Routine Semantics}
\texttt{ModelStructure(positions: list[Vector3D], partitions: list[partitionItem]) -> self}
\begin{itemize}
  \item \textbf{Transition:} creates a 3D array of blank voxels and initializes partition list
  \item \textbf{Output:} \texttt{self} - reference to created \texttt{ModelStructure} object
  \item \textbf{Exceptions:} None
\end{itemize}
\texttt{getLayer(z: int) -> list[Vector3D]}
\begin{itemize}
  \item \textbf{Transition:} returns all voxel centres at a specific vertical index
  \item \textbf{Output:} \texttt{list[Vector3D]} - the requested layer
  \item \textbf{Exceptions:} \texttt{IndexError} if index is out of bounds
\end{itemize}
\texttt{getProperty(index: tuple(int, int, int), property: propertyName) -> Any}
\begin{itemize}
  \item \textbf{Transition:} returns the requested property of the voxel at the given index
  \item \textbf{Output:} \texttt{Any} as the property may be represented in various ways
  \item \textbf{Exceptions:} \texttt{IndexError} if index is out of bounds
\end{itemize}
\texttt{setProperty(index: tuple(int, int, int), property: propertyName, value: Any) -> None}
\begin{itemize}
  \item \textbf{Transition:} sets the property specified to the value specified of the voxel at the given index
  \item \textbf{Output:} None
  \item \textbf{Exceptions:} \texttt{IndexError} if index is out of bounds
\end{itemize}
\texttt{hasProperty(index: tuple(int, int, int), property: propertyName) -> bool}
\begin{itemize}
  \item \textbf{Transition:} returns true if the voxel at the given index has an initialized non-blank value of the specified property
  \item \textbf{Output:} \texttt{bool} - indicating property initialization
  \item \textbf{Exceptions:} \texttt{IndexError} if index is out of bounds
\end{itemize}

\subsubsection{Local Functions}
None.

\newpage

\section{MIS of Graphics Adapter (M15)}\label{Module18}

GraphicsAdapter

\subsection{Module}
GraphicsAdapter handles all communication with the graphics API to enable visual rendering and generate a model on the UI.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item None
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{5cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{requestRender} & key: str, \newline update: dict[str] = Any & void & NetworkError \\
\texttt{getUpdateStatus} & key: str & bool & None \\
\texttt{checkServerStatus} & None & void & NetworkError \\
\hline
\end{tabular}
\end{center}



\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{updateStatus}: bool — tracks status of rendering completion.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
  \item \texttt{API\_BASE\_URL}: \textit{str} — external base URL for establishing environment configurations and enabling backend API requests.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
  \item Backend service is reachable and operational.
  \item Connection is available for API.
  \item Valid configurations exist for necessary API operations.
\end{itemize}
\subsubsection{Access Routine Semantics}

requestRender(key: str, update: dict[str] = Any) $\rightarrow$ void
\begin{itemize}
  \item Transition: sends a rendering request identified by the given key along with the associated update data to the graphics backend.
  \item Output: None.
  \item Exceptions: NetworkError if the rendering request cannot be transmitted.
\end{itemize}

getUpdateStatus(key: str) $\rightarrow$ bool
\begin{itemize}
  \item Transition: retrieves the current rendering status associated with the specified update key.
  \item Output: bool indicating whether rendering has completed successfully.
  \item Exceptions: None.
\end{itemize}

checkServerStatus() $\rightarrow$ void
\begin{itemize}
  \item Transition: checks connectivity and availability of the graphics backend service.
  \item Output: None.
  \item Exceptions: NetworkError if the backend service cannot be reached.
\end{itemize}

\newpage

\section{MIS of Export Structure (M16)}\label{Module20}

ExportStructure

\subsection{Module}
The ExportStructure module defines and implements the internal data structure for representing exported files, including field ordering, data types, and encoding format. It ensures consistency between internal model representations and external file layouts used during export operations.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{EXPORT\_SCHEMA\_VERSION}: str — current version of the export structure schema.
  \item \texttt{FIELD\_ORDER}: list[str] — ordered list of field names in export format: ["x", "y", "z", "layer", "materialId", "magnetizationX", "magnetizationY", "magnetizationZ"].
  \item \texttt{DEFAULT\_ENCODING}: str — default character encoding for export files (e.g., "UTF-8").
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{p{4cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{defineStructure} & format: str & dict[str] = Any & UnsupportedFormatError \\
\texttt{getFieldOrder} & format: str & list[str] & UnsupportedFormatError \\
\texttt{getFieldType} & fieldName: str & Any & InvalidFieldError \\
\texttt{validateStructure} & data: Any & bool & StructureMismatchError \\
\texttt{createHeader} & metadata: dict[str] = Any & dict[str] = Any & None \\
\bottomrule
\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{exportSchema}: ExportSchema — current export structure schema definition.
  \item \texttt{fieldTypes}: dict[str] = DataType — mapping from field names to their data types.
\end{itemize}

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
\begin{itemize}
  \item Export format identifiers match supported formats ("CSV").
  \item Field names in export data match those defined in \texttt{FIELD\_ORDER}.
  \item Data types conform to the schema defined by \texttt{fieldTypes}.
  \item Export structure remains consistent across export operations.
\end{itemize}

\subsubsection{Access Routine Semantics}

defineStructure(format: str) $\rightarrow$ dict[str] = Any
\begin{itemize}
  \item Transition: selects and defines the export structure schema corresponding to the specified export format and stores it as the active export schema.
  \item Output: dict[str] = Any representing the defined export schema.
  \item Exceptions: UnsupportedFormatError if the export format is not supported.
\end{itemize}

getFieldOrder(format: str) $\rightarrow$ list[str]
\begin{itemize}
  \item Transition: retrieves the ordered list of field names associated with the specified export format.
  \item Output: list[str] representing the field order.
  \item Exceptions: UnsupportedFormatError if the export format is not supported.
\end{itemize}

getFieldType(fieldName: str) $\rightarrow$ Any
\begin{itemize}
  \item Transition: retrieves the expected data type for the specified export field name.
  \item Output: Any representing the field’s data type.
  \item Exceptions: InvalidFieldError if the field name is not part of the export schema.
\end{itemize}

validateStructure(data: Any) $\rightarrow$ bool
\begin{itemize}
  \item Transition: checks whether the provided export data conforms to the active export schema and field ordering.
  \item Output: bool indicating whether the structure is valid.
  \item Exceptions: StructureMismatchError if the data does not match the export schema.
\end{itemize}

createHeader(metadata: dict[str] = Any) $\rightarrow$ dict[str] = Any
\begin{itemize}
  \item Transition: generates an export header using the provided metadata in accordance with the export schema.
  \item Output: dict[str] = Any representing the export header.
  \item Exceptions: None.
\end{itemize}


\subsubsection{Local Functions}
\begin{itemize}
  \item \texttt{mapInternalToExport(internalData: VoxelData) -> ExportData}: Maps internal voxel representation to export format structure.
  \item \texttt{validateFieldValue(fieldName: str, value: Any) -> bool}: Validates that a field value matches its expected data type.
  \item \texttt{encodeFieldValue(fieldName: str, value: Any) -> str}: Encodes a field value according to the export format specification.
\end{itemize}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\iffalse
\section{Appendix}\label{Appendix}

\wss{Extra information if required}

\newpage{}



\wss{Not required for CAS 741 projects}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.
\fi

\section*{Appendix --- Reflection}

\input{../../Reflection.tex}

% \begin{enumerate}
%   \item What went well while writing this deliverable? 
%   \item What pain points did you experience during this deliverable, and how
%     did you resolve them?
%   \item Which of your design decisions stemmed from speaking to your client(s)
%   or a proxy (e.g. your peers, stakeholders, potential users)? For those that
%   were not, why, and where did they come from?
%   \item While creating the design doc, what parts of your other documents (e.g.
%   requirements, hazard analysis, etc), it any, needed to be changed, and why?
%   \item What are the limitations of your solution?  Put another way, given
%   unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)
%   \item Give a brief overview of other design solutions you considered.  What
%   are the benefits and tradeoffs of those other designs compared with the chosen
%   design?  From all the potential options, why did you select the documented design?
%   (LO\_Explores)
% \end{enumerate}

\subsubsection*{1. What went well while writing this deliverable?}
\bigskip\bigskip
\textbf{Omar: }
\newline
\newline
\textbf{Daniel: } Overall, the two major issues I foresaw with this deliverbale - the restructuring of some modules and the formalization of the more complex pieces of our software - went smoother than I expected. The existing module decomposition made sense to me even though I did not work on the initial revision besides reviewing it, and the only major changes were altering the hierarchy. The formalization of how voxels are created also went better after some research that provided a base inspiration into how to define the algorithm's output.
\newline
\newline
\textbf{Andrew: } Integrating the UI and backend from Daniel went really well this deliverable. Working with him in unison was very helpful, and we got everything done in expert time.
\newline
\newline
\textbf{Olivia: } Overall, I think that this deliverable really emphasized understanding the structure of the code prior to execution. As someone who mainly focused on the documentation during Rev 0 and then took a more active role in the code development afterwards, the time spent on developing these design documents forced me to take a step back and understand how the system would ultimately fit together. This helped guide the process of writing the code, as I felt I had a better idea of what was expected of each module.There was also more clarity on how to structure things based on what the system would require, well ensuring all responsibilities and functionalities would be met. 
\newline
\newline
\textbf{Khalid: } In terms of the code, the things that went well were the splitting the structure into multiple layers so they can be edited at the same time without interfering with each other. I was also able to find a way to convert the web application to a desktop application using Electron if needed.

\subsubsection*{2. What pain points did you experience during this deliverable, and how
did you resolve them?}
\bigskip
\textbf{Omar: }
\newline
\newline
\textbf{Daniel: } A pain point I experienced was maintaining consistency with my partner. While the split between modules allowed us to work in parallel effectively, there was some overlap in types, which required us to examine our work and ensure we named things in the same fashion. Additionally, ensuring that the functions each module possessed needed to exist and what module would call it posed difficulty at times, especially for more abstract modules that are ultimately more implementation specific in their required functions.
\newline
\newline
\textbf{Andrew: } I was part of the code team for this deliverable, so like Khalid - I did not have many point points regarding this MIS. Of my own exploration and work, I built the MVP UI and made sure to include an initial renderer, export and import manager using javascript frameworks and previous implementations of STL renderers. The pain point here was to find a suitable renderer and have it work in unison with our other modules, but it was not too much of a headache.
\newline
\newline
\textbf{Olivia: } At first it was overwhelming to decompose the system in a way that clearly captured responsibilities and interactions without integrating premature design decisions. To help combat this issue, I decided to use the initial module decomposition as a guide. This ensured that when I went into more detail for the modules, I didn’t feel stuck on trying to develop a module that didn’t work. By keeping this open-minded approach during document development, it placed less pressure on the initial decomposition, and ensured that the modules chosen in our final document were included because they actually hold value. 
\newline
\newline
\textbf{Khalid: } I was part of the code team for this deliverable, so I didn't have any pain points regarding the document. However, in terms of the pain points I experienced for the code, I worked on the splitting the structure into multiple layers so they can be edited at the same time without interfering with each other. The pain point I had was finding an algorithm that will efficiently split the structure into multiple layers. I ended up using a simple algorithm that will split the structure into multiple layers based on the z-coordinate.

\subsubsection*{3. Which of your design decisions stemmed from speaking to your client(s)
or a proxy (e.g. your peers, stakeholders, potential users)? For those that
were not, why, and where did they come from?}

\subsubsection*{4. While creating the design doc, what parts of your other documents (e.g.
requirements, hazard analysis, etc), it any, needed to be changed, and why?}

During the creation of the Design Docs, a major changed revolved around a missing requirement identified - the ability to manually save projects. The SRS required an update throughout many of its sections, as well as the VnV Plan which required an additional functional system test. Many of the other changes were actually in the reverse direction; consistency changes in the SRS or VnV that trickled into changed in the Design Docs, however most of these changes were minor (e.g. the alteration of wording to align with wording in other documents).

\subsubsection*{5. What are the limitations of your solution?  Put another way, given
unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)}

\subsubsection*{6. Give a brief overview of other design solutions you considered.  What
are the benefits and tradeoffs of those other designs compared with the chosen
design?  From all the potential options, why did you select the documented design?
(LO\_Explores)}

\end{document}
