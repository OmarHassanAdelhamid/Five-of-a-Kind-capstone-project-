\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\newcounter{mnum}
\newcommand{\mthemnum}{M\themnum}
\newcommand{\mref}[1]{M\ref{#1}}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
November 10, 2025 & 1.0 & Initial draft by All\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See \href{https://github.com/OmarHassanAdelhamid/Five-of-a-Kind-capstone-project-/blob/main/docs/SRS-Meyer/requirements/SRS.pdf}{SRS} Documentation.

\iffalse
\wss{Also add any additional symbols, abbreviations or acronyms}
\fi

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
\wss{Fill in your project name and description}

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/OmarHassanAdelhamid/Five-of-a-Kind-capstone-project-}

\section{Notation}

\wss{You should describe your notation.  You can use what is below as
  a starting point.}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule

{Hardware-Hiding} & ~ \\
\midrule

\multirow{7}{0.3\textwidth}{Behaviour-Hiding} & Input Parameters\\
& Output Format\\
& Output Verification\\
& Temperature ODEs\\
& Energy Equations\\ 
& Control Module\\
& Specification Parameters Module\\
\midrule

\multirow{3}{0.3\textwidth}{Software Decision} & {Sequence Data Structure}\\
& ODE Solver\\
& Plotting\\
\bottomrule

\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

\newpage

\section{MIS of Project Manager} \label{m4}

\subsection{Module}

ProjectManager

\subsection{Uses}

ModelStructure (\mref{m16})

\subsection{Syntax}

\subsubsection{Exported Constants}

None

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{5cm} p{5cm} p{4cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
ProjectManager & - & self & IOError \\
\multirow{2}{*}{create\_project} & \multirow{2}{*}{project\_path: str, config: dict} & \multirow{2}{*}{None} & \textbullet{} IOError \\
 &  &  & \textbullet{} ValueError \\
\multirow{2}{*}{load\_project} & \multirow{2}{*}{project\_path: str} & \multirow{2}{*}{None} & \textbullet{} IOError \\
 &  &  & \textbullet{} FileNotFoundError \\
save\_project & project\_path: str & None & IOError \\
get\_project\_metadata & - & dict & - \\
initialize\_workspace & workspace\_path: str & None & IOError \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
\item \texttt{project\_path}: str - Path to the current project directory
\item \texttt{workspace\_root}: str - Root directory of the workspace
\item \texttt{project\_metadata}: dict - Dictionary containing project configuration and metadata
\item \texttt{model}: ModelStructure - Reference to the model structure instance
\item \texttt{is\_initialized}: bool - Flag indicating if the project has been initialized
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
\item \texttt{FILE\_SYSTEM}: The file system where project files are stored
\item \texttt{WORKSPACE\_ROOT}: Root directory environment variable for workspace location
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
\item The file system has sufficient space for project creation
\item The provided project path is a valid directory path
\item Write permissions are available for the project directory
\item The workspace root directory exists or can be created
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
\item \texttt{validate\_config(config: dict) -> bool}: Validates that the configuration dictionary contains required fields
\item \texttt{create\_project\_structure(path: str) -> None}: Creates the directory structure for a new project
\item \texttt{read\_metadata\_file(path: str) -> dict}: Reads and parses project metadata from file
\item \texttt{write\_metadata\_file(path: str, metadata: dict) -> None}: Writes project metadata to file
\end{itemize}

\newpage

\section{MIS of Export Validation} \label{m12}

\subsection{Module}

ExportValidation

\subsection{Uses}

ModelStructure (\mref{m16})

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
\item \texttt{MAX\_VOXELS}: $\mathbb{Z}$ = 13996800000 - Maximum number of voxels allowed
\item \texttt{MAX\_LAYERS}: $\mathbb{Z}$ = 518400 - Maximum number of layers allowed
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{5cm} p{5cm} p{5cm} p{3cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
validate\_export\_readiness & model: ModelStructure & ValidationResult & - \\
check\_printer\_compatibility & model: ModelStructure & bool & - \\
check\_property\_completeness & model: ModelStructure & list[str] & - \\
validate\_file\_format & file\_path: str & bool & IOError \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None

\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

\begin{itemize}
\item The model structure provided is valid and properly initialized
\item All voxels in the model have consistent property structures
\item File paths provided are accessible and readable
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
\item \texttt{count\_voxels(model: ModelStructure) -> $\mathbb{Z}$}: Counts the total number of voxels in the model
\item \texttt{count\_layers(model: ModelStructure) -> $\mathbb{Z}$}: Counts the total number of layers in the model
\item \texttt{check\_printer\_specs(model: ModelStructure) -> bool}: Validates model against printer-specific constraints
\end{itemize}

\newpage

\section{MIS of Export Manager} \label{m13}

\subsection{Module}

ExportManager

\subsection{Uses}

\begin{itemize}
\item ModelStructure (\mref{m16})
\item ExportValidation (\mref{m12})
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
\item \texttt{DEFAULT\_EXPORT\_FORMAT}: str = "CSV" - Default export file format
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
ExportManager & - & self & - \\
\multirow{2}{*}{export\_project} & \multirow{2}{*}{model: ModelStructure, export\_path: str, format: str} & \multirow{2}{*}{None} & \textbullet{} IOError \\
 &  &  & \textbullet{} ValueError \\
transform\_to\_export\_format & model: ModelStructure, format: str & ExportData & - \\
serialize\_data & data: ExportData, format: str & str & ValueError \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
\item \texttt{export\_format}: str - Current export format being used
\item \texttt{export\_config}: dict - Configuration settings for export operations
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
\item \texttt{FILE\_SYSTEM}: The file system where export files are written
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
\item The model structure provided has been validated for export readiness
\item The export path directory exists or can be created
\item Write permissions are available for the export directory
\item The export format is supported
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
\item \texttt{group\_voxels\_by\_layer(model: ModelStructure) -> dict}: Groups voxels by their layer Z-coordinate
\item \texttt{encode\_csv(export\_data: ExportData) -> str}: Encodes export data into CSV format string
\item \texttt{validate\_export\_path(path: str) -> bool}: Validates that the export path is writable
\item \texttt{create\_export\_directory(path: str) -> None}: Creates the export directory if it does not exist
\end{itemize}

\newpage

\section{MIS of Error Diagnostic Handler} \label{m14}

\subsection{Module}

ErrorDiagnosticHandler

\subsection{Uses}

None

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
\item \texttt{ERROR\_MODEL\_UNRESPONSIVE}: str = "MODEL\_UNRESPONSIVE" - Error code for unresponsive model
\item \texttt{ERROR\_GRAPHICS\_UPDATE}: str = "GRAPHICS\_UPDATE\_FAILURE" - Error code for graphics update failure
\item \texttt{ERROR\_FILE\_ISSUE}: str = "FILE\_OPERATION\_ERROR" - Error code for file operation errors
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{5cm} p{5cm} p{5cm} p{3cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
detect\_error & error\_context: dict & ErrorDiagnostic & - \\
classify\_error & error\_code: str, error\_context: dict & ErrorType & - \\
log\_error & error\_diagnostic: ErrorDiagnostic & None & IOError \\
handle\_error\_recovery & error\_diagnostic: ErrorDiagnostic & RecoveryAction & - \\
get\_error\_source & error\_diagnostic: ErrorDiagnostic & str & - \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
\item \texttt{error\_log}: list[ErrorDiagnostic] - History of detected errors
\item \texttt{error\_patterns}: dict - Patterns for error classification
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
\item \texttt{LOG\_FILE}: File system location for error logging
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
\item Error context dictionaries contain sufficient information for diagnosis
\item Log file location is writable
\item Error codes follow the defined constants
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
\item \texttt{analyze\_error\_pattern(error\_context: dict) -> str}: Analyzes error context to identify error patterns
\item \texttt{determine\_error\_source(context: dict) -> str}: Determines the source component from error context
\item \texttt{format\_error\_message(error\_code: str, context: dict) -> str}: Formats a human-readable error message
\item \texttt{suggest\_recovery\_steps(error\_type: ErrorType) -> list[str]}: Generates recovery step suggestions based on error type
\end{itemize}

\newpage

\section{MIS of Model Structure} \label{m16}

\subsection{Module}

ModelStructure

\subsection{Uses}

None

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
\item \texttt{VOXEL\_SIZE\_XY}: $\mathbb{R}$ = 300.0 - Voxel size in X and Y dimensions (micrometers)
\item \texttt{VOXEL\_SIZE\_Z}: $\mathbb{R}$ = 110.0 - Voxel size in Z dimension (micrometers)
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{5cm} p{5cm} p{5cm} p{4cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
ModelStructure & dimensions: tuple[$\mathbb{Z}$, $\mathbb{Z}$, $\mathbb{Z}$] & self & ValueError \\
get\_voxel & position: tuple[$\mathbb{Z}$, $\mathbb{Z}$, $\mathbb{Z}$] & Voxel & IndexError \\
set\_voxel & position: tuple[$\mathbb{Z}$, $\mathbb{Z}$, $\mathbb{Z}$], voxel: Voxel & None & IndexError \\
get\_layer & z: $\mathbb{Z}$ & Layer & IndexError \\
\multirow{2}{*}{get\_property} & \multirow{2}{*}{position: tuple[$\mathbb{Z}$, $\mathbb{Z}$, $\mathbb{Z}$], property\_name: str} & \multirow{2}{*}{Any} & \textbullet{} IndexError \\
 &  &  & \textbullet{} KeyError \\
\multirow{2}{*}{set\_property} & \multirow{2}{*}{position: tuple[$\mathbb{Z}$, $\mathbb{Z}$, $\mathbb{Z}$], property\_name: str, value: Any} & \multirow{2}{*}{None} & \textbullet{} IndexError \\
 &  &  & \textbullet{} ValueError \\
add\_layer & layer: Layer & None & ValueError \\
get\_metadata & - & dict & - \\
set\_metadata & key: str, value: Any & None & - \\
validate\_voxel & voxel: Voxel & bool & - \\
has\_material & voxel: Voxel & bool & - \\
has\_magnetization & voxel: Voxel & bool & - \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
\item \texttt{voxel\_grid}: 3D array[Voxel] - Three-dimensional grid storing voxel data
\item \texttt{layers}: list[Layer] - Ordered list of layers, indexed by Z-coordinate
\item \texttt{metadata}: dict - Dictionary containing model metadata (dimensions, material properties, etc.)
\item \texttt{dimensions}: tuple[$\mathbb{Z}$, $\mathbb{Z}$, $\mathbb{Z}$] - Grid dimensions (X, Y, Z)
\end{itemize}

\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

\begin{itemize}
\item Voxel positions are within the grid boundaries defined by \texttt{dimensions}
\item Layer ordering follows Z-axis ordering (bottom to top)
\item Property names are consistent across voxels
\item Material types and magnetization vectors conform to expected formats
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
\item \texttt{validate\_position(position: tuple[$\mathbb{Z}$, $\mathbb{Z}$, $\mathbb{Z}$]) -> bool}: Checks if position is within grid boundaries
\item \texttt{maintain\_layer\_ordering() -> None}: Ensures layers remain ordered by Z-coordinate
\item \texttt{create\_layer\_from\_z(z: $\mathbb{Z}$) -> Layer}: Creates a new layer structure for a given Z-coordinate
\item \texttt{validate\_property\_value(property\_name: str, value: Any) -> bool}: Validates that a property value conforms to expected type and constraints
\end{itemize}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\newpage{}

\section*{Appendix --- Reflection}

\wss{Not required for CAS 741 projects}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.

\input{../../Reflection.tex}

\begin{enumerate}
  \item What went well while writing this deliverable? 
  \item What pain points did you experience during this deliverable, and how
    did you resolve them?
  \item Which of your design decisions stemmed from speaking to your client(s)
  or a proxy (e.g. your peers, stakeholders, potential users)? For those that
  were not, why, and where did they come from?
  \item While creating the design doc, what parts of your other documents (e.g.
  requirements, hazard analysis, etc), it any, needed to be changed, and why?
  \item What are the limitations of your solution?  Put another way, given
  unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)
  \item Give a brief overview of other design solutions you considered.  What
  are the benefits and tradeoffs of those other designs compared with the chosen
  design?  From all the potential options, why did you select the documented design?
  (LO\_Explores)
\end{enumerate}


\end{document}