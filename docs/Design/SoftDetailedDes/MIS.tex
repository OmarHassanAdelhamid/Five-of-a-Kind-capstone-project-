\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\newcommand{\mref}[1]{M\ref{#1}}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
November 13, 2025 & 1.0 & Initial draft by All\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See \href{https://github.com/OmarHassanAdelhamid/Five-of-a-Kind-capstone-project-/blob/main/docs/SRS-Meyer/requirements/SRS.pdf}{SRS} Documentation.

\iffalse
\wss{Also add any additional symbols, abbreviations or acronyms}
\fi

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for \progname{}. \progname{} is a desktop-based CAD enhancement tool that enables researchers and engineers to assign magnetic and material properties to individual voxels within a 3D model. The system allows users to import CAD files (STL format), automatically convert them into voxel grids, and interactively select and modify voxels layer by layer to assign magnetization directions and material assignments. This tool streamlines the magnetization planning process for multi-material 3D printing workflows in research laboratory environments.

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/OmarHassanAdelhamid/Five-of-a-Kind-capstone-project-}

\section{Notation}

\iffalse
\wss{You should describe your notation.  You can use what is below as
  a starting point.}
\fi

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
  \centering
  \begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
  \toprule
  \textbf{Level 1} & \textbf{Level 2}\\
  \midrule
  
  {Hardware-Hiding Module} & None \\
  \midrule
  
  \multirow{7}{0.3\textwidth}{Behaviour-Hiding Module} & Input Interpreter Module\\
  & Voxel Slicing Module\\
  & Display Partitioning Module\\
  & Project Manager Module\\
  & Serialization Manager Module\\
  & Backend Communication Manager Module\\
  & Interaction Controller Module\\
  & Visualization State Manager Module\\
  & Model Manager Module\\
  & History Manager Module\\
  & Autosave Manager Module\\
  & Voxel Tracking Module\\
  & Highlight Manager Module\\
  & Export Validation Module\\
  & Export Manager Module\\
  & Error Diagnostic Handler Module\\
  \midrule
  
  \multirow{3}{0.3\textwidth}{Software Decision Module} & Model Structure Module\\
  & Graphics Adapter Module\\
  & Database Handler Module\\
  & Export Structure Module\\
  \bottomrule
  
  \end{tabular}
  \caption{Module Hierarchy}
  \label{TblMH}
  \end{table}
\newpage
~\newpage

\section{MIS of Input Interpreter} \label{Module1}

\subsection{Module}
InputInterpreter is responsible for importing and parsing model or project files (e.g., STL, JSON) and normalizing them into a consistent internal format that downstream modules can process.

\subsection{Uses}
\begin{itemize}
  \item VoxelSlicing (M2) for voxel grid generation.
  \item SerializationManager (M5) for project deserialization.
  \item ModelStructure (M17) for organizing parsed geometry data.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{SUPPORTED\_FORMATS}: list[string] — supported file types (STL, JSON, binary).
  \item \texttt{DEFAULT\_SCALE}: float — default scaling applied to geometry.
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{p{3.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{loadFile} & filePath: string & IntermediateModel & FileNotFoundError, UnsupportedFileTypeError \\
\texttt{detectFormat} & filePath: string & string & None \\
\texttt{parseSTL} & fileData: string & MeshModel & ParseError \\
\texttt{deserializeProject} & fileData: string & ProjectModel & SchemaMismatchError \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{currentModel}: IntermediateModel — latest parsed internal representation.
  \item \texttt{detectedFormat}: string — identifies file type.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
  \item \texttt{FILE\_PATH}: string — path to the input file on the filesystem.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
  \item The file path exists and is readable.
  \item Data structure conforms to supported file format.
  \item Deserialized data follows expected schema.
\end{itemize}

\subsubsection{Access Routine Semantics}
\begin{itemize}
  \item \texttt{loadFile(filePath)}: detects format and calls parsing logic.
  \[
  currentModel :=
  \begin{cases}
  parseSTL(fileData) & \text{if STL format}\\
  deserializeProject(fileData) & \text{if Project format}
  \end{cases}
  \]
  \item \texttt{detectFormat(filePath)}: returns file type by inspecting header or extension.
  \item \texttt{parseSTL(fileData)}: converts triangular facets \(t_i=(n_i,v_{i1},v_{i2},v_{i3})\), where \(n_i,v_{ij}\in\mathbb{R}^3\), into internal mesh structure.
  \item \texttt{deserializeProject(fileData)}: decodes serialized voxel data and metadata.
\end{itemize}

\subsubsection{Exceptions}
\begin{itemize}
  \item \texttt{FileNotFoundError} — invalid path or unreadable file.
  \item \texttt{UnsupportedFileTypeError} — format not recognized.
  \item \texttt{ParseError} — malformed geometry or facet data.
  \item \texttt{SchemaMismatchError} — project schema invalid or outdated.
\end{itemize}


\section{MIS of Voxel Slicing} \label{Module2}

\subsection{Module}
VoxelSlicing is responsible for converting the geometric model into a structured voxel grid. It divides the 3D model along the Z-axis into discrete slices based on a specified resolution, mapping geometry into voxelized layers for simulation and visualization.

\subsection{Uses}
\begin{itemize}
  \item InputInterpreter (M1) — provides intermediate geometric model data.
  \item ModelManager (M9) — receives generated voxel grid for management and updates.
  \item ModelStructure (M17) — defines the voxel and layer data structures.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{DEFAULT\_RESOLUTION}: tuple(float, float, float) — default voxel size in x, y, and z directions.
  \item \texttt{MAX\_LAYERS}: int — maximum number of layers allowed per model.
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{p{3.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{voxelizeModel} & model: IntermediateModel, resolution: tuple & VoxelGrid & ResolutionError, GeometryError \\
\texttt{generateLayers} & voxelGrid: VoxelGrid & list[Layer] & None \\
\texttt{setResolution} & resolution: tuple & void & InvalidResolutionError \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{voxelGrid}: VoxelGrid — stores the resulting voxelized representation.
  \item \texttt{layerList}: list[Layer] — ordered collection of Z-level layers.
  \item \texttt{resolution}: tuple(float, float, float) — current voxel grid spacing.
\end{itemize}

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
\begin{itemize}
  \item Input model geometry is well-defined and watertight.
  \item Resolution values are positive real numbers.
  \item The number of layers does not exceed system memory capacity.
\end{itemize}

\subsubsection{Access Routine Semantics}
\begin{itemize}
  \item \texttt{voxelizeModel(model, resolution)}: Converts mesh geometry into voxel occupancy.
  \[
  G = \{v_{xyz} \mid x,y,z \in \mathbb{N},\ \text{facet intersects voxel}(x,y,z)\}
  \]
  \item \texttt{generateLayers(voxelGrid)}: Groups voxels into Z-level layers.
  \[
  L = \{l_k = \{v_{xyz} \mid z = k \cdot r_z\}\ |\ k \in [1,n]\}
  \]
  \item \texttt{setResolution(resolution)}: Updates internal resolution state.
\end{itemize}

\subsubsection{Exceptions}
\begin{itemize}
  \item \texttt{ResolutionError} — invalid resolution leading to empty grid.
  \item \texttt{GeometryError} — malformed or non-manifold geometry detected.
  \item \texttt{InvalidResolutionError} — one or more components of resolution $\le 0$.
\end{itemize}

\section{MIS of Display Partitioning} \label{Module3} 

DisplayPartitioning

\subsection{Module}
The DisplayPartitioning module provides core functionality for partitioning the model into distinct display segments.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ModelManager} to obtain the sliced model's data representation.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\noindent\textbf{Exported Constants}

\begin{itemize}
  \item \texttt{MAX\_PARTITION}: \textit{int} — maximum number of partitions that can be created.
  \item \texttt{MAX\_VOXEL\_PARTITION}: \textit{int} — maximum number of voxels per partition.
  \item \texttt{AVAILABLE\_PARTITIONS}: \textit{List[string]} — configuration of valid partition IDs used by the display layout.
\end{itemize}

\noindent\textbf{Exported Access Programs}:
\begin{center}
  \renewcommand{\arraystretch}{1.55}
  \begin{tabular}{p{4cm} p{5cm} p{3cm} p{3cm}}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
  \hline
  
  \texttt{getPartitions} &
  None &
  \textit{dict[string]} &
  None \\
  
  \texttt{setCurrentPartition} &
  id: \textit{string} \newline
  partition: \textit{PartitionItem} &
  void &
  None \\
  
  \texttt{resizePartitions} &
  id: \textit{string} \newline
  width: \textit{int} \newline
  height: \textit{int} \newline
  depth: \textit{int} &
  void &
  None \\
  
  \end{tabular}
  \end{center}
\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{PartitionItem}: \textit{record} — configuration for data that describes a partition.
  \item \texttt{PartitionDict}: \textit{dict[string] = PartitionItem} — tracks all partitions.
\end{itemize}

\subsubsection{Environment Variables}
None

  \subsubsection{Assumptions}
  \begin{itemize}
    \item A valid and complete \texttt{ModelStructure} exists.
    \item Display partitions adhere only to positive dimensions.
    \item \texttt{AVAILABLE\_PARTITIONS} provides the display layout with a preset mapping to UI grid positions.
  \end{itemize}
\newpage

\section{MIS of Serialization Manager} \label{Module5}

\subsection{Module}
SerializationManager handles conversion of all internal model data between in-memory and persistent storage forms (JSON or binary). It ensures data integrity, schema consistency, and supports both saving and restoring complete project states.

\subsection{Uses}
\begin{itemize}
  \item ModelManager (M9) — supplies model state to be serialized.
  \item DatabaseHandler (M19) — stores serialized data persistently.
  \item ExportManager (M15) — exports encoded model structures to files.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{SUPPORTED\_FORMATS}: list[string] — allowed serialization formats \{JSON, BIN\}.
  \item \texttt{CURRENT\_SCHEMA\_VERSION}: string — defines latest project data schema.
\end{itemize}


\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{p{4cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{encodeModel} & model: ModelState & string & SerializationError \\
\texttt{decodeModel} & data: string & ModelState & DeserializationError, SchemaMismatchError \\
\texttt{verifySchema} & data: string & bool & SchemaMismatchError \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{serializedData}: string — current encoded representation.
  \item \texttt{schemaVersion}: string — identifies schema used during last encode/decode.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
  \item \texttt{SAVE\_PATH}: string — default file path for serialized model data.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
  \item Input model follows internal data structure specification.
  \item Decoded data matches the expected schema version.
  \item File system paths used for storage are valid and writable.
\end{itemize}

\subsubsection{Access Routine Semantics}
\begin{itemize}
  \item \texttt{encodeModel(model)}: Converts in-memory state to JSON string.  
  \[
  S := \text{JSON.stringify}(model)
  \]
  Ensures \( Decode(S) = model \).
  \item \texttt{decodeModel(data)}: Parses JSON/BIN data back to full ModelState.
  \[
  M' := \text{JSON.parse}(data)
  \]
  \item \texttt{verifySchema(data)}: Checks that schema version in data header matches \texttt{CURRENT\_SCHEMA\_VERSION}.
\end{itemize}

\subsubsection{Exceptions}
\begin{itemize}
  \item \texttt{SerializationError} — error while encoding data to string.
  \item \texttt{DeserializationError} — input data corrupted or incomplete.
  \item \texttt{SchemaMismatchError} — version mismatch detected in schema validation.
\end{itemize}


\section{MIS of Backend Communication Manager} \label{Module6} 

BackendCommunicator
  
\subsection{Module}
The BackendCommunicator module manages the transfer and synchronization of data between the backend server and frontend UI.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ModelManager} for interpretation into backend-compatible commands.
  \item \texttt{SerializationManager} for necessary JSON and binary transforms.
  \item \texttt{InteractionController} for processing raw UI information.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\noindent\textbf{Exported Constants}

\begin{itemize}
  \item None
\end{itemize}

\noindent\textbf{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{5cm} p{3cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline

\texttt{checkServerStatus} &
None &
Promise\textless void\textgreater&
Network Error \\

\texttt{initDataLogs} &
None &
Promise\textless boolean\textgreater &
Network Error \\

\texttt{getDataLogs} &
None &
string &
None \\

\texttt{getInteraction} &
None &
UIdata: string &
None \\

\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{serverStatus}: \textit{ServerStatusType} — tracks the current connection status of the backend server.
  \item \texttt{data\_log}: \textit{string} — all data gathered from the frontend that requires interpretation on the backend.
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item \texttt{SERVER\_URL}: \textit{string} — backend server URL from environment configuration.
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
  \item Backend service is reachable and operational.
  \item Connection is available for data synchronization.
  \item Valid configurations exist for necessary data transfer operations.
\end{itemize}


\newpage

\section{MIS of Interaction Controller} \label{Module7} 

InteractionController

\subsection{Module}
The InteractionController module manages the process of raw events from interaction with UI to associated actions within internal code.

\subsection{Uses}
\begin{itemize}
  \item \texttt{VisualizationManager} to establish current active view.
  \item \texttt{BackendCommunicationManager} for taking the collected raw UI data from the frontend and sending it for interpretation.
  \item \texttt{ModelManager} for handling user intent related to model modification.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\noindent\textbf{Exported Constants}

\begin{itemize}
  \item \texttt{UI\_EVENTS}: \textit{list[string]} — identifies all supported UI events that can be detected from user interaction.
  \item \texttt{UI\_ACTIONS}: \textit{list[string]} — identifies all supported interactions that can be derived from UI events.
\end{itemize}

\noindent\textbf{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{4cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline

\texttt{interpretEvent} &
UIdata: \textit{string} &
UIEvent &
None \\

\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{currentEvent}: \textit{UIEvent} — configuration for a UI event.
  \item \texttt{currentView}: \textit{string} — identifies what view is currently displayed during interaction.
  \item \texttt{pointerPosition}: \textit{[int, int]} — pointer coordinates captured from the most recent relevant event.
  \item \texttt{allEvents}: \textit{list[string]} — identifies all supported UI events that can be detected from user interaction.
\end{itemize}

\subsubsection{Environment Variables}
None


\subsubsection{Assumptions}
\begin{itemize}
  \item User intent does not exceed the scope of supported actions that can be derived.
  \item There can only be one current active view at a given moment.
  \item \texttt{pointerPosition} is contained within the screen resolution.
\end{itemize}

\newpage

\section{MIS of Visualization State Manager} \label{Module8}

VisualizationManager

\subsection{Module}
The VisualizationManager module oversees the creation of UI views while managing subsequent updates to the display state of the specified current UI views on a backend level.

\subsection{Uses}
\begin{itemize}
  \item \texttt{DisplayPartitioning} for tracking different interface states across partitions.
  \item \texttt{GraphicsAdapter} for rendering updates visible to user.
  \item \texttt{ModelManager} for managing model and metadata updates that affect state visualization.
  \item \texttt{HighlightManager} for managing change in voxels being highlighted.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{DEFAULT\_VIEWS}: \textit{list[string]} — list of identifiers corresponding to the default views generated upon project initialization.
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{6cm} p{3cm} p{2.5cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{getCurrentView} & None & ViewState & None \\
\texttt{setView} & state: \textit{ViewState} & void & None \\
\texttt{getHighlightState} & None & HighlightState & None \\
\texttt{updateModel} & voxelCoords: \textit{List[VoxelCoord]} \\ updateType: \textit{ModelUpdateType} & void & None \\
\texttt{updateHighlight} & semanticKey: \textit{string} & void & None \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{currentView}: \textit{string} — identifies which UI view is currently shown to the user.
  \item \texttt{viewStatus}: \textit{dict[string] = ViewItem} — stores all data encapsulated within a UI view.
  \item \texttt{updateBundle}: \textit{dict[string] = UpdateItem} — stores all data needed to update a UI view upon a render request.
  \item \texttt{pendingUpdates}: \textit{list[UpdateKey]} — updates waiting to be processed in rendering.
  \item \texttt{renderStatus}: \textit{boolean} — records the success status of the rendering process.
  \item \texttt{supportedViews}: \textit{list[string]} — identifiers corresponding to all available project views.
\end{itemize}

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
\begin{itemize}
  \item Partitions are initialized.
  \item ViewItem is properly formatted in accordance with ViewItem specification.
  \item UpdateItem is properly formatted in accordance with UpdateItem specification.
  \item \texttt{currentView}, \texttt{ViewState}, and \texttt{DEFAULT\_VIEWS} are elements of \texttt{supportedViews}.
\end{itemize}


\section{MIS of Model Manager} \label{Module9}

\subsection{Module}
ModelManager oversees the management and manipulation of the voxel-based 3D model. It provides APIs to add, remove, or modify voxels, update magnetization/material properties, and synchronize changes with autosave and history tracking modules.

\subsection{Uses}
\begin{itemize}
  \item VoxelSlicing (M2) — supplies initial voxel grid data.
  \item SerializationManager (M5) — encodes or decodes model states for storage.
  \item HistoryManager (M10) — records changes for undo/redo.
  \item VoxelTracking (M12) — queries voxel properties.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{MAX\_VOXEL\_COUNT}: int — maximum allowed voxel entries per project.
  \item \texttt{AUTOSAVE\_INTERVAL\_S}: float — time threshold (in seconds) before triggering autosave.
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{p{4cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{addVoxel} & coord: VoxelCoord, material: MaterialType, mag: Vector3 & void & InvalidInputError \\
\texttt{removeVoxel} & coord: VoxelCoord & void & NotFoundError \\
\texttt{modifyVoxel} & coord: VoxelCoord, newData: VoxelData & void & NotFoundError \\
\texttt{saveModel} & None & bool & IOerror \\
\texttt{loadModel} & filePath: string & bool & DeserializationError \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{voxelGrid}: VoxelGrid — stores all voxel elements and layer mapping.
  \item \texttt{metadata}: dict — contains file name, author, timestamp, etc.
  \item \texttt{autosaveTimer}: float — time since last autosave.
  \item \texttt{unsavedChanges}: bool — true if edits have occurred since last save.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
  \item \texttt{SAVE\_PATH}: string — default save location for serialized project data.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
  \item Voxel coordinates fall within the defined model boundaries.
  \item Data supplied for voxel modifications are valid according to schema.
  \item Autosave operations will not interrupt ongoing edits.
\end{itemize}

\subsubsection{Access Routine Semantics}
\begin{itemize}
  \item \texttt{addVoxel(coord, material, mag)}: Adds new voxel entry at specified coordinate.
  \[
  G' = G \cup \{v = (coord, material, mag)\}
  \]
  Triggers \texttt{HistoryManager.push}($\Delta M$).
  
  \item \texttt{removeVoxel(coord)}: Deletes voxel from grid and logs change.
  \[
  G' = G \setminus \{v \mid v.coord = coord\}
  \]

  \item \texttt{modifyVoxel(coord, newData)}: Updates voxel’s attributes.
  \[
  v' = newData \text{ if } v.coord = coord
  \]

  \item \texttt{saveModel()}: Serializes model and writes to file via \texttt{SerializationManager}.
  \item \texttt{loadModel(filePath)}: Deserializes project data from storage and rebuilds voxel grid.
\end{itemize}

\subsubsection{Exceptions}
\begin{itemize}
  \item \texttt{InvalidInputError} — malformed coordinate or data type.
  \item \texttt{NotFoundError} — voxel coordinate not present in grid.
  \item \texttt{IOerror} — failure during save operation.
  \item \texttt{DeserializationError} — corrupted or incompatible input file.
\end{itemize}


\section{MIS of History Manager} \label{Module10}

\subsection{Module}
HistoryManager maintains the complete change history of the 3D voxel model.  
It allows undoing and redoing edits by recording incremental changes (deltas) after every modification.

\subsection{Uses}
\begin{itemize}
  \item ModelManager (M9) — provides the model changes to record.
  \item SerializationManager (M5) — encodes snapshots for persistence.
  \item AutosaveManager (M11) — references latest history state during periodic saves.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{MAX\_HISTORY\_SIZE}: int — maximum number of undo states stored.
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{p{4cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{recordChange} & delta: ModelDelta & void & None \\
\texttt{undo} & None & bool & EmptyHistoryError \\
\texttt{redo} & None & bool & EmptyHistoryError \\
\texttt{clearHistory} & None & void & None \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{historyStack}: list[ModelState] — sequence of previous model states.
  \item \texttt{redoStack}: list[ModelState] — sequence of undone model states available for redo.
  \item \texttt{currentIndex}: int — current pointer in the history sequence.
\end{itemize}

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
\begin{itemize}
  \item Changes are discrete and atomic.
  \item No new change is made while undo or redo is in progress.
  \item The number of stored states does not exceed \texttt{MAX\_HISTORY\_SIZE}.
\end{itemize}

\subsubsection{Access Routine Semantics}
\begin{itemize}
  \item \texttt{recordChange(delta)}:  
  Pushes a new state to the \texttt{historyStack} and clears \texttt{redoStack}.  
  \[
  historyStack := historyStack \cup \{currentState + \Delta M\}
  \]
  \item \texttt{undo()}:  
  Restores the last recorded state and moves it to \texttt{redoStack}.
  \item \texttt{redo()}:  
  Retrieves the latest undone state from \texttt{redoStack} and reapplies it.
  \item \texttt{clearHistory()}:  
  Resets both history and redo stacks.
\end{itemize}

\subsubsection{Exceptions}
\begin{itemize}
  \item \texttt{EmptyHistoryError} — when attempting undo or redo with no entries available.
\end{itemize}


\section{MIS of Autosave Manager} \label{Module11} 

AutosaveManager

\subsection{Module}
The AutosaveManager module prepares data to be saved, monitors when updates require saving, and invokes periodic scheduled transfers to file-based storage.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ModelManager} for tracking changes that require savings.
  \item \texttt{SerializationManager} for data preparation.
  \item \texttt{HistoryManager} for logging recent changes.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\noindent\textbf{Exported Constants}

\begin{itemize}
  \item \texttt{AUTOSAVE\_INTERVAL\_MS}: \textit{int} — minimum amount of time (in milliseconds) between autosave operations.
  \item \texttt{FILE\_ID}: \textit{string} — file to which autosave operations are written.
\end{itemize}

\noindent\textbf{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{3cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline

\texttt{forceSave} &
None &
None &
IO Error \\

\texttt{enableAutosave} &
None &
None &
None \\

\texttt{disableAutosave} &
None &
None &
None \\

\texttt{lastAutosaveTime} &
None &
DateTime &
None \\

\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{autosavePermission}: \textit{bool} — indicates whether autosave is enabled or disabled.
  \item \texttt{lastAutosave}: \textit{DateTime} — timestamp of last transfer to file-based storage.
  \item \texttt{autosaveHistory}: \textit{dict[DateTime] = Update} — complete log of transfers to file-based storage.
\end{itemize}


\subsubsection{Environment Variables}

\begin{itemize}
  \item \texttt{SYSTEM\_TIME}: \textit{DateTime} — global time supplied by the current system.
\end{itemize}


\subsubsection{Assumptions}
\begin{itemize}
  \item \texttt{SYSTEM\_TIME} always increases monotonically.
  \item Data preparation method is compatible with file-based storage.
  \item Connection is available to file-based storage.
  \item Valid configuration exists for operations to file-based storage.
\end{itemize}

\newpage

\section{MIS of Voxel Tracking} \label{Module12} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

\wss{Short name for the module}

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}

\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\newpage

\section{MIS of Highlight Manager} \label{Module13} 

HighlightManager

\subsection{Module}
The HighlightManager module manages the voxel highlights in accordance with visual semantic meaning.

\subsection{Uses}
\begin{itemize}
  \item \texttt{Visualization State Manager} for managing visual updates related to voxel highlights.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\noindent\textbf{Exported Constants}

\begin{itemize}
  \item \texttt{DEFAULT\_HIGHLIGHT\_MAP}: \textit{dict[string, string]} — mapping from semantic keys to their default highlight colours.
\end{itemize}

\noindent\textbf{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{5cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline

\texttt{getHighlight} &
semanticKey: \textit{string} &
ColourValue &
None \\

\texttt{editPalette} &
semanticKey: \textit{string} \newline
newColour: \textit{ColourValue} &
void &
None \\

\texttt{setHighlight} &
semanticKey: \textit{string} &
void &
None \\

\texttt{resetPalette} &
None &
void &
None \\

\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{highlightColourMap}: \textit{dict[string, string]} — current mapping from semantic keys to active highlight colours.
\end{itemize}

\subsubsection{Environment Variables}
None


\subsubsection{Assumptions}
\begin{itemize}
  \item Semantic keys must correspond to valid entries maintained by the TrackingManager.
  \item Colour values are valid colour representations.
\end{itemize}

\newpage

\section{MIS of Export Validation} \label{Module14}

ExportValidation

\subsection{Module}

The ExportValidation module validates export readiness by checking export file format requirements, verifying completeness of voxel properties (material and magnetization), and ensuring all export constraints are met. 

\subsection{Uses}
\begin{itemize}
  \item \texttt{ModelStructure} to obtain the model structure and data representation.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
\item \texttt{MAX\_VOXELS}: $\mathbb{Z}$ = 13996800000 - Maximum number of voxels allowed
\item \texttt{MAX\_LAYERS}: $\mathbb{Z}$ = 518400 - Maximum number of layers allowed
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{5cm} p{5cm} p{3.5cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
validate\_export\_readiness & model: ModelStructure & ValidationResult & - \\
check\_printer\_compatibility & model: ModelStructure & bool & - \\
check\_property\_completeness & model: ModelStructure & list[str] & - \\
validate\_file\_format & file\_path: str & bool & IOError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None

\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

\begin{itemize}
\item The model structure provided is valid and properly initialized
\item All voxels in the model have consistent property structures
\item File paths provided are accessible and readable
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
\item \texttt{count\_voxels(model: ModelStructure) -> $\mathbb{Z}$}: Counts the total number of voxels in the model
\item \texttt{count\_layers(model: ModelStructure) -> $\mathbb{Z}$}: Counts the total number of layers in the model
\item \texttt{check\_printer\_specs(model: ModelStructure) -> bool}: Validates model against printer-specific constraints
\end{itemize}

\newpage

\section{MIS of Export Manager} \label{Module15} 

ExportManager

\subsection{Module}

The ExportManager module coordinates the export process, transforms internal model data into export-compatible formats, and serializes project data including voxel grids, metadata, material properties, and magnetization information according to export specifications.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ModelStructure} to obtain the model structure and data representation.
  \item \texttt{ExportValidation} to get the export validation result.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}


\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
\item \texttt{DEFAULT\_EXPORT\_FORMAT}: str = "CSV" - Default export file format
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{6cm} p{5cm} p{2cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
ExportManager & - & self & - \\
export\_project & model: ModelStructure, \newline export\_path: str, \newline format: str & None & \textbullet{} IOError \newline \textbullet{} ValueError \\
transform\_to\_export\_format & model: ModelStructure, \newline format: str & ExportData & - \\
serialize\_data & data: ExportData, \newline format: str & str & ValueError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
\item \texttt{export\_format}: str - Current export format being used
\item \texttt{export\_config}: dict - Configuration settings for export operations
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
\item \texttt{FILE\_SYSTEM}: The file system where export files are written
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
\item The model structure provided has been validated for export readiness
\item The export path directory exists or can be created
\item Write permissions are available for the export directory
\item The export format is supported
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
\item \texttt{group\_voxels\_by\_layer(model: ModelStructure) -> dict}: Groups voxels by their layer Z-coordinate
\item \texttt{encode\_csv(export\_data: ExportData) -> str}: Encodes export data into CSV format string
\item \texttt{validate\_export\_path(path: str) -> bool}: Validates that the export path is writable
\item \texttt{create\_export\_directory(path: str) -> None}: Creates the export directory if it does not exist
\end{itemize}

\newpage

\section{MIS of Error Diagnostic Handler } \label{Module16}

ErrorDiagnosticHandler

\subsection{Module}

The ErrorDiagnosticHandler module detects, diagnoses, and handles errors that occur during model operations, graphics rendering, and file interactions. It provides error classification, logging, and recovery mechanisms to ensure system stability and user feedback.

\subsection{Uses}

None

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
\item \texttt{ERROR\_MODEL\_UNRESPONSIVE}: str = "MODEL\_UNRESPONSIVE" - Error code for unresponsive model
\item \texttt{ERROR\_GRAPHICS\_UPDATE}: str = "GRAPHICS\_UPDATE\_FAILURE" - Error code for graphics update failure
\item \texttt{ERROR\_FILE\_ISSUE}: str = "FILE\_OPERATION\_ERROR" - Error code for file operation errors
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{5cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
detect\_error & error\_context: dict & ErrorDiagnostic & - \\
classify\_error & error\_code: str, \newline error\_context: dict & ErrorType & - \\
log\_error & error\_diagnostic: ErrorDiagnostic & None & IOError \\
handle\_error\_recovery & error\_diagnostic: ErrorDiagnostic & RecoveryAction & - \\
get\_error\_source & error\_diagnostic: ErrorDiagnostic & str & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{error\_log}: list[ErrorDiagnostic] - History of detected errors
\item \texttt{error\_patterns}: dict - Patterns for error classification
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
\item \texttt{LOG\_FILE}: File system location for error logging
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
\item Error context dictionaries contain sufficient information for diagnosis
\item Log file location is writable
\item Error codes follow the defined constants
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
\item \texttt{analyze\_error\_pattern(error\_context: dict) -> str}: Analyzes error context to identify error patterns
\item \texttt{determine\_error\_source(context: dict) -> str}: Determines the source component from error context
\item \texttt{format\_error\_message(error\_code: str, context: dict) -> str}: Formats a human-readable error message
\item \texttt{suggest\_recovery\_steps(error\_type: ErrorType) -> list[str]}: Generates recovery step suggestions based on error type
\end{itemize}

\newpage


\section{MIS of Model Structure} \label{Module17}

ModelStructure

\subsection{Module}

The ModelStructure module stores and organizes all voxel and layer data for the model, including per-voxel properties, metadata, and structural dimensions.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ModelManager} for managing the model structure and data representation.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
\item \texttt{VOXEL\_SIZE\_XY}: $\mathbb{R}$ = 300.0 - Voxel size in X and Y dimensions (micrometers)
\item \texttt{VOXEL\_SIZE\_Z}: $\mathbb{R}$ = 110.0 - Voxel size in Z dimension (micrometers)
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{5cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
ModelStructure & dimensions: tuple[$\mathbb{Z}$, \newline $\mathbb{Z}$, $\mathbb{Z}$] & self & ValueError \\
get\_voxel & position: tuple[$\mathbb{Z}$, \newline $\mathbb{Z}$, $\mathbb{Z}$] & Voxel & IndexError \\
set\_voxel & position: tuple[$\mathbb{Z}$, \newline $\mathbb{Z}$, $\mathbb{Z}$], \newline voxel: Voxel & None & IndexError \\
get\_layer & z: $\mathbb{Z}$ & Layer & IndexError \\
get\_property & position: tuple[$\mathbb{Z}$, \newline $\mathbb{Z}$, $\mathbb{Z}$], \newline property\_name: str & Any & \textbullet{} IndexError \newline \textbullet{} KeyError \\
set\_property & position: tuple[$\mathbb{Z}$, \newline $\mathbb{Z}$, $\mathbb{Z}$], \newline property\_name: str, \newline value: Any & None & \textbullet{} IndexError \newline \textbullet{} ValueError \\
add\_layer & layer: Layer & None & ValueError \\
get\_metadata & - & dict & - \\
set\_metadata & key: str, \newline value: Any & None & - \\
validate\_voxel & voxel: Voxel & bool & - \\
has\_material & voxel: Voxel & bool & - \\
has\_magnetization & voxel: Voxel & bool & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{voxel\_grid}: 3D array[Voxel] - Three-dimensional grid storing voxel data
\item \texttt{layers}: list[Layer] - Ordered list of layers, indexed by Z-coordinate
\item \texttt{metadata}: dict - Dictionary containing model metadata (dimensions, material properties, etc.)
\item \texttt{dimensions}: tuple[$\mathbb{Z}$, $\mathbb{Z}$, $\mathbb{Z}$] - Grid dimensions (X, Y, Z)
\end{itemize}

\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

\begin{itemize}
\item Voxel positions are within the grid boundaries defined by \texttt{dimensions}
\item Layer ordering follows Z-axis ordering (bottom to top)
\item Property names are consistent across voxels
\item Material types and magnetization vectors conform to expected formats
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
\item \texttt{validate\_position(position: tuple[$\mathbb{Z}$, $\mathbb{Z}$, $\mathbb{Z}$]) -> bool}: Checks if position is within grid boundaries
\item \texttt{maintain\_layer\_ordering() -> None}: Ensures layers remain ordered by Z-coordinate
\item \texttt{create\_layer\_from\_z(z: $\mathbb{Z}$) -> Layer}: Creates a new layer structure for a given Z-coordinate
\item \texttt{validate\_property\_value(property\_name: str, value: Any) -> bool}: Validates that a property value conforms to expected type and constraints
\end{itemize}

\newpage

\section{MIS of Graphics Adapter} \label{Module18}

GraphicsAdapter

\subsection{Module}
GraphicsAdapter handles all communication with the graphics API to enable visual rendering and generate a model on the UI.

\subsection{Uses}
\begin{itemize}
  \item \texttt{VisualizationManager} aggregates necessary backend data and relays updates to the rendered view.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item None
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{5cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{requestRender} & str: \textit{UpdateKey} \\ update: \textit{UpdateBundle} & void & NetworkError \\
\texttt{getUpdateStatus} & str: \textit{UpdateKey} & boolean & None \\
\texttt{checkServerStatus} & None & Promise\textless void\textgreater & NetworkError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{updateStatus}: \textit{boolean} — tracks status of rendering completion.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
  \item \texttt{API\_BASE\_URL}: \textit{string} — external base URL for establishing environment configurations and enabling backend API requests.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
  \item Backend service is reachable and operational.
  \item Connection is available for API.
  \item Valid configurations exist for necessary API operations.
\end{itemize}


\newpage

\section{MIS of Database Handler} \label{Module19}

\subsection{Module}
DatabaseHandler manages persistent storage for project and model data. It provides standardized interfaces for reading, writing, and deleting serialized model files, ensuring version integrity and consistent access to saved projects.

\subsection{Uses}
\begin{itemize}
  \item SerializationManager (M5) — encodes and decodes model data before storage.
  \item ModelManager (M9) — provides model structures to persist.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{DEFAULT\_SAVE\_DIR}: string — default directory path for project files.
  \item \texttt{DB\_FORMAT\_VERSION}: string — current format version for data compatibility.
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{p{4cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \midrule
\texttt{saveProject} & id: string, data: SerializedModel & bool & IOError \\
\texttt{loadProject} & id: string & SerializedModel & FileNotFoundError \\
\texttt{deleteProject} & id: string & bool & IOError \\
\texttt{listProjects} & None & list[string] & None \\ \bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{projectMap}: dict[string, SerializedModel] — mapping of project identifiers to serialized data.
  \item \texttt{storagePath}: string — root directory for persistent project files.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
  \item \texttt{FILE\_SYSTEM}: OS-level file system used for reading/writing project data.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
  \item Project IDs are unique.
  \item File I/O operations succeed given sufficient permissions.
  \item SerializationManager ensures schema compatibility before writing data.
\end{itemize}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

\wss{Short name for the module}

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}

\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\newpage

\section{MIS of Export Structure} \label{Module20} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

\wss{Short name for the module}

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}

\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\newpage{}

\section*{Appendix --- Reflection}

\wss{Not required for CAS 741 projects}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.

\input{../../Reflection.tex}

\begin{enumerate}
  \item What went well while writing this deliverable? 
  \item What pain points did you experience during this deliverable, and how
    did you resolve them?
  \item Which of your design decisions stemmed from speaking to your client(s)
  or a proxy (e.g. your peers, stakeholders, potential users)? For those that
  were not, why, and where did they come from?
  \item While creating the design doc, what parts of your other documents (e.g.
  requirements, hazard analysis, etc), it any, needed to be changed, and why?
  \item What are the limitations of your solution?  Put another way, given
  unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)
  \item Give a brief overview of other design solutions you considered.  What
  are the benefits and tradeoffs of those other designs compared with the chosen
  design?  From all the potential options, why did you select the documented design?
  (LO\_Explores)
\end{enumerate}


\end{document}
