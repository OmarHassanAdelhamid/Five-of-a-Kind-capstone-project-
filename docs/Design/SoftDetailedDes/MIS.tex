\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\newcommand{\mref}[1]{M\ref{#1}}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
November 13, 2025 & 1.0 & Initial draft by All\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See \href{https://github.com/OmarHassanAdelhamid/Five-of-a-Kind-capstone-project-/blob/main/docs/SRS-Meyer/requirements/SRS.pdf}{SRS} Documentation.

\iffalse
\wss{Also add any additional symbols, abbreviations or acronyms}
\fi

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for \progname{}. \progname{} is a desktop-based CAD enhancement tool that enables researchers and engineers to assign magnetic and material properties to individual voxels within a 3D model. The system allows users to import CAD files (STL format), automatically convert them into voxel grids, and interactively select and modify voxels layer by layer to assign magnetization directions and material assignments. This tool streamlines the magnetization planning process for multi-material 3D printing workflows in research laboratory environments.

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/OmarHassanAdelhamid/Five-of-a-Kind-capstone-project-}

\section{Notation}

\iffalse
\wss{You should describe your notation.  You can use what is below as
  a starting point.}
\fi

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
string & str & a sequence of characters\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
boolean & bool & True or False\\
any type & Any & any data type is acceptable\\
list & list[T] & an ordered collection of objects of type T\\
set & set[T] & an unordered collection of unique objects of type T\\
dictionary & dict[key] = value & data structure containing multiple key-value pairs\\
tuple & tuple[T$_1$, T$_2$, \ldots] or tuple[T] & an ordered collection of values, potentially of different types\\
void & void & indicates no return value\\
current instance & self & a reference to the current instance of a module\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
  \centering
  \caption{Module Hierarchy}\label{TblMH}
  \begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
  \toprule
  \textbf{Level 1} & \textbf{Level 2}\\
  \midrule
  
  {Hardware-Hiding Module} & None \\
  \midrule
  
  \multirow{7}{0.3\textwidth}{Behaviour-Hiding Module} & Input Interpreter Module (M1)\\
  & Voxel Slicing Module (M2)\\
  & Display Partitioning Module (M3)\\
  & Project Manager Module (M4)\\
  & Serialization Manager Module (M5)\\
  & Backend Communication Manager Module (M6)\\
  & Interaction Controller Module (M7)\\
  & Visualization State Manager Module (M8)\\
  & Model Manager Module (M9)\\
  & History Manager Module (M10)\\
  & Autosave Manager Module (M11)\\
  & Voxel Tracking Module (M12)\\
  & Highlight Manager Module (M13)\\
  & Export Validation Module (M14)\\
  & Export Manager Module (M15)\\
  & Error Diagnostic Handler Module (M16)\\
  \midrule
  
  \multirow{3}{0.3\textwidth}{Software Decision Module} & Model Structure Module (M17)\\
  & Graphics Adapter Module (M18)\\
  & Database Handler Module (M19)\\
  & Export Structure Module (M20)\\
  \bottomrule
  
  \end{tabular}
  \end{table}
\newpage
~\newpage

\section{MIS of Input Interpreter (M1)}\label{Module1}

InputInterpreter

\subsection{Module}
The InputInterpreter module is responsible for importing and parsing model or project files (e.g., STL, CSV) and normalizing them into a consistent internal format that downstream modules can process.

\subsection{Uses}
\begin{itemize}
  \item \texttt{SerializationManager} for the input file deserialization.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
  \item \texttt{VoxelSlicing} for voxel grid generation and layer generation.
  \item \texttt{DisplayPartitioning} for display partitioning the model.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{SUPPORTED\_FORMATS}: list[str] — supported file types (STL, CSV, binary).
  \item \texttt{DEFAULT\_SCALE}: float — default scaling applied to geometry.
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{p{3.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{loadFile} & filePath: str & IntermediateModel & FileNotFoundError, UnsupportedFileTypeError \\
\texttt{detectFormat} & filePath: str & str & None \\
\texttt{parseSTL} & fileData: str & MeshModel & ParseError \\
\texttt{deserializeProject} & fileData: str & ProjectModel & SchemaMismatchError \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{currentModel}: IntermediateModel — latest parsed internal representation.
  \item \texttt{detectedFormat}: str — identifies file type.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
  \item \texttt{FILE\_PATH}: str — path to the input file on the filesystem.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
  \item The file path exists and is readable.
  \item Data structure conforms to supported file format.
  \item Deserialized data follows expected schema.
\end{itemize}

\iffalse
\subsubsection{Access Routine Semantics}
\begin{itemize}
  \item \texttt{loadFile(filePath)}: detects format and calls parsing logic.
  \[
  currentModel :=
  \begin{cases}
  parseSTL(fileData) & \text{if STL format}\\
  deserializeProject(fileData) & \text{if Project format}
  \end{cases}
  \]
  \item \texttt{detectFormat(filePath)}: returns file type by inspecting header or extension.
  \item \texttt{parseSTL(fileData)}: converts triangular facets \(t_i=(n_i,v_{i1},v_{i2},v_{i3})\), where \(n_i,v_{ij}\in\mathbb{R}^3\), into internal mesh structure.
  \item \texttt{deserializeProject(fileData)}: decodes serialized voxel data and metadata.
\end{itemize}

\subsubsection{Exceptions}
\begin{itemize}
  \item \texttt{FileNotFoundError} — invalid path or unreadable file.
  \item \texttt{UnsupportedFileTypeError} — format not recognized.
  \item \texttt{ParseError} — malformed geometry or facet data.
  \item \texttt{SchemaMismatchError} — project schema invalid or outdated.
\end{itemize}
\fi

\section{MIS of Voxel Slicing (M2)}\label{Module2}

VoxelSlicing

\subsection{Module}
The VoxelSlicing module is responsible for converting the geometric model into a structured voxel grid. It divides the 3D model along the Z-axis into discrete slices based on a specified resolution, mapping geometry into voxelized layers for simulation and visualization.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ProjectManager} to get the model structure and data representation, and store the resulting voxel grid and layer list.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{DEFAULT\_RESOLUTION}: tuple(float, float, float) — default voxel size in x, y, and z directions.
  \item \texttt{MAX\_LAYERS}: int — maximum number of layers allowed per model.
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{p{3.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{voxelizeModel} & model: IntermediateModel, resolution: tuple & VoxelGrid & ResolutionError, GeometryError \\
\texttt{generateLayers} & voxelGrid: VoxelGrid & list[Layer] & None \\
\texttt{setResolution} & resolution: tuple & void & InvalidResolutionError \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{voxelGrid}: VoxelGrid — stores the resulting voxelized representation.
  \item \texttt{layerList}: list[Layer] — ordered collection of Z-level layers.
  \item \texttt{resolution}: tuple(float, float, float) — current voxel grid spacing.
\end{itemize}

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
\begin{itemize}
  \item Input model geometry is well-defined and watertight.
  \item Resolution values are positive real numbers.
  \item The number of layers does not exceed system memory capacity.
\end{itemize}

\iffalse
\subsubsection{Access Routine Semantics}
\begin{itemize}
  \item \texttt{voxelizeModel(model, resolution)}: Converts mesh geometry into voxel occupancy.
  \[
  G = \{v_{xyz} \mid x,y,z \in \mathbb{N},\ \text{facet intersects voxel}(x,y,z)\}
  \]
  \item \texttt{generateLayers(voxelGrid)}: Groups voxels into Z-level layers.
  \[
  L = \{l_k = \{v_{xyz} \mid z = k \cdot r_z\}\ |\ k \in [1,n]\}
  \]
  \item \texttt{setResolution(resolution)}: Updates internal resolution state.
\end{itemize}

\subsubsection{Exceptions}
\begin{itemize}
  \item \texttt{ResolutionError} — invalid resolution leading to empty grid.
  \item \texttt{GeometryError} — malformed or non-manifold geometry detected.
  \item \texttt{InvalidResolutionError} — one or more components of resolution $\le 0$.
\end{itemize}
\fi
\section{MIS of Display Partitioning (M3)}\label{Module3} 

DisplayPartitioning

\subsection{Module}
The DisplayPartitioning module provides core functionality for partitioning the model into distinct display segments.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ProjectManager} to get the model structure and data representation, and store the resulting voxel grid and layer list.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
  \item \texttt{MAX\_PARTITION}: int — maximum number of partitions that can be created.
  \item \texttt{MAX\_VOXEL\_PARTITION}: int — maximum number of voxels per partition.
  \item \texttt{AVAILABLE\_PARTITIONS}: list[str] — configuration of valid partition IDs used by the display layout.
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
  \renewcommand{\arraystretch}{1.55}
  \begin{tabular}{p{4cm} p{5cm} p{3cm} p{3cm}}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
  \hline
  
  \texttt{getPartitions} &
  None &
  dict[str] &
  None \\
  
  \texttt{setCurrentPartition} &
  id: str, \newline
  partition: partitionItem &
  void &
  None \\
  
  \texttt{resizePartitions} &
  id: str, \newline
  width: int, \newline
  height: int, \newline
  depth: int &
  void &
  None \\
  
  \end{tabular}
  \end{center}
\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{partitionItem}: record — configuration for data that describes a partition.
  \item \texttt{partitionDict}: dict[str] = partitionItem — tracks all partitions.
\end{itemize}

\subsubsection{Environment Variables}
None

  \subsubsection{Assumptions}
  \begin{itemize}
    \item A valid and complete \texttt{ModelStructure} exists.
    \item Display partitions adhere only to positive dimensions.
    \item \texttt{AVAILABLE\_PARTITIONS} provides the display layout with a preset mapping to UI grid positions.
  \end{itemize}
\newpage

\section{MIS of Project Manager (M4)}\label{Module4}

ProjectManager

\subsection{Module}

The ProjectManager module manages the creation, initialization, and persistence of project workspaces, handles project metadata storage, and ensures project resources are properly allocated.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ModelManager} to obtain and create the model structure and data representation.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

None

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{5cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{ProjectManager} & - & self & IOError \\
\texttt{createProject} & projectPath: str, \newline config: dict & None & IOError, \newline ValueError \\
\texttt{loadProject} & projectPath: str & None & IOError, \newline FileNotFoundError \\
\texttt{saveProject} & projectPath: str & None & IOError \\
\texttt{getProjectMetadata} & - & dict & - \\
\texttt{initializeWorkspace} & workspacePath: str & None & IOError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
\item \texttt{projectPath}: str - Path to the current project directory
\item \texttt{workspaceRoot}: str - Root directory of the workspace
\item \texttt{projectMetadata}: dict - Dictionary containing project configuration and metadata
\item \texttt{model}: ModelStructure - Reference to the model structure instance
\item \texttt{isInitialized}: bool - Flag indicating if the project has been initialized
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
\item \texttt{FILE\_SYSTEM}: The file system where project files are stored
\item \texttt{WORKSPACE\_ROOT}: Root directory environment variable for workspace location
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
\item The file system has sufficient space for project creation
\item The provided project path is a valid directory path
\item Write permissions are available for the project directory
\item The workspace root directory exists or can be created
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
\item \texttt{validateConfig(config: dict) -> bool}: Validates that the configuration dictionary contains required fields
\item \texttt{createProjectStructure(path: str) -> None}: Creates the directory structure for a new project
\item \texttt{readMetadataFile(path: str) -> dict}: Reads and parses project metadata from file
\item \texttt{writeMetadataFile(path: str, metadata: dict) -> None}: Writes project metadata to file
\end{itemize}

\newpage


\section{MIS of Serialization Manager (M5)}\label{Module5}

SerializationManager

\subsection{Module}
The SerializationManager module handles the conversion of all internal model data between in-memory and persistent storage forms (JSON or binary). It ensures data integrity, schema consistency, and supports both saving and restoring complete project states.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ModuleManager} to get the current module state.
  \item \texttt{AutosaveManager} to get the current autosave state.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{SUPPORTED\_FORMATS}: list[str] — allowed serialization formats \{JSON, BIN\}.
  \item \texttt{CURRENT\_SCHEMA\_VERSION}: str — defines latest project data schema.
\end{itemize}


\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{p{4cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{encodeModel} & model: ModelState & str & SerializationError \\
\texttt{decodeModel} & data: str & ModelState & DeserializationError, SchemaMismatchError \\
\texttt{verifySchema} & data: str & bool & SchemaMismatchError \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{serializedData}: str — current encoded representation.
  \item \texttt{schemaVersion}: str — identifies schema used during last encode/decode.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
  \item \texttt{SAVE\_PATH}: str — default file path for serialized model data.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
  \item Input model follows internal data structure specification.
  \item Decoded data matches the expected schema version.
  \item File system paths used for storage are valid and writable.
\end{itemize}

\iffalse
\subsubsection{Access Routine Semantics}
\begin{itemize}
  \item \texttt{encodeModel(model)}: Converts in-memory state to JSON string.  
  \[
  S := \text{JSON.stringify}(model)
  \]
  Ensures \( Decode(S) = model \).
  \item \texttt{decodeModel(data)}: Parses JSON/BIN data back to full ModelState.
  \[
  M' := \text{JSON.parse}(data)
  \]
  \item \texttt{verifySchema(data)}: Checks that schema version in data header matches \texttt{CURRENT\_SCHEMA\_VERSION}.
\end{itemize}

\subsubsection{Exceptions}
\begin{itemize}
  \item \texttt{SerializationError} — error while encoding data to string.
  \item \texttt{DeserializationError} — input data corrupted or incomplete.
  \item \texttt{SchemaMismatchError} — version mismatch detected in schema validation.
\end{itemize}
\fi

\section{MIS of Backend Communication Manager (M6)}\label{Module6} 

BackendCommunicator
  
\subsection{Module}
The BackendCommunicator module manages the transfer and synchronization of data between the backend server and frontend UI.

\subsection{Uses}
\begin{itemize}
  \item \texttt{SerializationManager} for necessary JSON, binary, and CSV transforms.
  \item \texttt{InteractionController} for processing interaction data from the frontend.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
  \item None
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{5cm} p{3cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline

\texttt{checkServerStatus} &
None &
Promise\textless void\textgreater&
Network Error \\

\texttt{initDataLogs} &
None &
Promise\textless bool\textgreater &
Network Error \\

\texttt{getDataLogs} &
None &
str &
None \\

\texttt{getInteraction} &
None &
UIdata: str &
None \\

\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{serverStatus}: ServerStatusType — tracks the current connection status of the backend server.
  \item \texttt{dataLog}: str — all data gathered from the frontend that requires interpretation on the backend.
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item \texttt{SERVER\_URL}: str — backend server URL from environment configuration.
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
  \item Backend service is reachable and operational.
  \item Connection is available for data synchronization.
  \item Valid configurations exist for necessary data transfer operations.
\end{itemize}


\newpage

\section{MIS of Interaction Controller (M7)}\label{Module7} 

InteractionController

\subsection{Module}
The InteractionController module manages the process of raw events from interaction with the UI to associated actions within internal code.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ModelManager} to handle user intent related to model modification.
  \item \texttt{ExportManager} to handle user intent related to export.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
  \item \texttt{UI\_EVENTS}: list[str] — identifies all supported UI events that can be detected from user interaction.
  \item \texttt{UI\_ACTIONS}: list[str] — identifies all supported interactions that can be derived from UI events.
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{4cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline

\texttt{interpretEvent} &
UIdata: str &
UIEvent &
None \\

\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{currentEvent}: UIEvent — configuration for a UI event.
  \item \texttt{currentView}: str — identifies what view is currently displayed during interaction.
  \item \texttt{pointerPosition}: [int, int] — pointer coordinates captured from the most recent relevant event.
  \item \texttt{allEvents}: list[str] — identifies all supported UI events that can be detected from user interaction.
\end{itemize}

\subsubsection{Environment Variables}
None


\subsubsection{Assumptions}
\begin{itemize}
  \item User intent does not exceed the scope of supported actions that can be derived.
  \item There can only be one current active view at a given moment.
  \item \texttt{pointerPosition} is contained within the screen resolution.
\end{itemize}

\newpage

\section{MIS of Visualization State Manager (M8)}\label{Module8}

VisualizationManager

\subsection{Module}
The VisualizationManager module oversees the creation of UI views while managing subsequent updates to the display state of the specified current UI views on a backend level.

\subsection{Uses}
\begin{itemize}
  \item \texttt{GraphicsAdapter} for rendering updates visible to user.
  \item \texttt{VoxelTracking} for specifying the set of voxels affected by a given update.
  \item \texttt{HighlightManager} for managing change in voxels being highlighted.
  \item \texttt{InteractionController} for handling user interaction data from the frontend.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{DEFAULT\_VIEWS}: list[str] — list of identifiers corresponding to the default views generated upon project initialization.
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{6cm} p{3cm} p{2.5cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{getCurrentView} & None & ViewState & None \\
\texttt{setView} & state: ViewState & void & None \\
\texttt{getHighlightState} & None & HighlightState & None \\
\texttt{updateModel} & voxelCoords: list[VoxelCoord], \newline updateType: ModelUpdateType & void & None \\
\texttt{updateHighlight} & semanticKey: str & void & None \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{currentView}: str — identifies which UI view is currently shown to the user.
  \item \texttt{viewStatus}: dict[str] = ViewItem — stores all data encapsulated within a UI view.
  \item \texttt{updateBundle}: dict[str] = UpdateItem — stores all data needed to update a UI view upon a render request.
  \item \texttt{pendingUpdates}: list[UpdateKey] — updates waiting to be processed in rendering.
  \item \texttt{renderStatus}: bool — records the success status of the rendering process.
  \item \texttt{supportedViews}: list[str] — identifiers corresponding to all available project views.
\end{itemize}

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
\begin{itemize}
  \item Partitions are initialized.
  \item ViewItem is properly formatted in accordance with ViewItem specification.
  \item UpdateItem is properly formatted in accordance with UpdateItem specification.
  \item \texttt{currentView}, \texttt{ViewState}, and \texttt{DEFAULT\_VIEWS} are elements of \texttt{supportedViews}.
\end{itemize}


\section{MIS of Model Manager (M9)}\label{Module9}

ModelManager

\subsection{Module}
The ModelManager module oversees the management and manipulation of the voxel-based 3D model. It provides APIs to add, remove, or modify voxels, update magnetization/material properties, and synchronize changes with autosave and history tracking modules.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ModelStructure} to get the model structure and data representation.
  \item \texttt{VisualizationManager} to get the current view state.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{MAX\_VOXEL\_COUNT}: int — maximum allowed voxel entries per project.
  \item \texttt{AUTOSAVE\_INTERVAL\_S}: float — time threshold (in seconds) before triggering autosave.
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{p{4cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{addVoxel} & coord: VoxelCoord, material: MaterialType, mag: Vector3 & void & InvalidInputError \\
\texttt{removeVoxel} & coord: VoxelCoord & void & NotFoundError \\
\texttt{modifyVoxel} & coord: VoxelCoord, newData: VoxelData & void & NotFoundError \\
\texttt{saveModel} & None & bool & IOerror \\
\texttt{loadModel} & filePath: str & bool & DeserializationError \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{voxelGrid}: VoxelGrid — stores all voxel elements and layer mapping.
  \item \texttt{metadata}: dict — contains file name, author, timestamp, etc.
  \item \texttt{autosaveTimer}: float — time since last autosave.
  \item \texttt{unsavedChanges}: bool — true if edits have occurred since last save.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
  \item \texttt{SAVE\_PATH}: str — default save location for serialized project data.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
  \item Voxel coordinates fall within the defined model boundaries.
  \item Data supplied for voxel modifications are valid according to schema.
  \item Autosave operations will not interrupt ongoing edits.
\end{itemize}

\iffalse
\subsubsection{Access Routine Semantics}
\begin{itemize}
  \item \texttt{addVoxel(coord, material, mag)}: Adds new voxel entry at specified coordinate.
  \[
  G' = G \cup \{v = (coord, material, mag)\}
  \]
  Triggers \texttt{HistoryManager.push}($\Delta M$).
  
  \item \texttt{removeVoxel(coord)}: Deletes voxel from grid and logs change.
  \[
  G' = G \setminus \{v \mid v.coord = coord\}
  \]

  \item \texttt{modifyVoxel(coord, newData)}: Updates voxel’s attributes.
  \[
  v' = newData \text{ if } v.coord = coord
  \]

  \item \texttt{saveModel()}: Serializes model and writes to file via \texttt{SerializationManager}.
  \item \texttt{loadModel(filePath)}: Deserializes project data from storage and rebuilds voxel grid.
\end{itemize}

\subsubsection{Exceptions}
\begin{itemize}
  \item \texttt{InvalidInputError} — malformed coordinate or data type.
  \item \texttt{NotFoundError} — voxel coordinate not present in grid.
  \item \texttt{IOerror} — failure during save operation.
  \item \texttt{DeserializationError} — corrupted or incompatible input file.
\end{itemize}
\fi

\section{MIS of History Manager (M10)}\label{Module10}

HistoryManager

\subsection{Module}
The HistoryManager module maintains the complete change history of the 3D voxel model.  
It allows undoing and redoing edits by recording incremental changes (deltas) after every modification.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{MAX\_HISTORY\_SIZE}: int — maximum number of undo states stored.
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{p{4cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{recordChange} & delta: ModelDelta & void & None \\
\texttt{undo} & None & bool & EmptyHistoryError \\
\texttt{redo} & None & bool & EmptyHistoryError \\
\texttt{clearHistory} & None & void & None \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{historyStack}: list[ModelState] — sequence of previous model states.
  \item \texttt{redoStack}: list[ModelState] — sequence of undone model states available for redo.
  \item \texttt{currentIndex}: int — current pointer in the history sequence.
\end{itemize}

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
\begin{itemize}
  \item Changes are discrete and atomic.
  \item No new change is made while undo or redo is in progress.
  \item The number of stored states does not exceed \texttt{MAX\_HISTORY\_SIZE}.
\end{itemize}

\iffalse
\subsubsection{Access Routine Semantics}
\begin{itemize}
  \item \texttt{recordChange(delta)}:  
  Pushes a new state to the \texttt{historyStack} and clears \texttt{redoStack}.  
  \[
  historyStack := historyStack \cup \{currentState + \Delta M\}
  \]
  \item \texttt{undo()}:  
  Restores the last recorded state and moves it to \texttt{redoStack}.
  \item \texttt{redo()}:  
  Retrieves the latest undone state from \texttt{redoStack} and reapplies it.
  \item \texttt{clearHistory()}:  
  Resets both history and redo stacks.
\end{itemize}

\subsubsection{Exceptions}
\begin{itemize}
  \item \texttt{EmptyHistoryError} — when attempting undo or redo with no entries available.
\end{itemize}
\fi

\section{MIS of Autosave Manager (M11)}\label{Module11} 

AutosaveManager

\subsection{Module}
The AutosaveManager module prepares data to be saved, monitors when updates require saving, and invokes periodic scheduled transfers to file-based storage.

\subsection{Uses}
\begin{itemize}
  \item \texttt{HistoryManager} to get the latest history state during periodic saves.
  \item \texttt{DatabaseHandler} to store serialized data persistently.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
  \item \texttt{AUTOSAVE\_INTERVAL\_MS}: int — minimum amount of time (in milliseconds) between autosave operations.
  \item \texttt{FILE\_ID}: str — file to which autosave operations are written.
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{3cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline

\texttt{forceSave} &
None &
None &
IO Error \\

\texttt{enableAutosave} &
None &
None &
None \\

\texttt{disableAutosave} &
None &
None &
None \\

\texttt{lastAutosaveTime} &
None &
DateTime &
None \\

\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{autosavePermission}: bool — indicates whether autosave is enabled or disabled.
  \item \texttt{lastAutosave}: DateTime — timestamp of last transfer to file-based storage.
  \item \texttt{autosaveHistory}: dict[DateTime] = Update — complete log of transfers to file-based storage.
\end{itemize}


\subsubsection{Environment Variables}

\begin{itemize}
  \item \texttt{SYSTEM\_TIME}: DateTime — global time supplied by the current system.
\end{itemize}


\subsubsection{Assumptions}
\begin{itemize}
  \item \texttt{SYSTEM\_TIME} always increases monotonically.
  \item Data preparation method is compatible with file-based storage.
  \item Connection is available to file-based storage.
  \item Valid configuration exists for operations to file-based storage.
\end{itemize}

\newpage

\section{MIS of Voxel Tracking (M12)}\label{Module12}

VoxelTracking

\subsection{Module}
The VoxelTracking module interprets the voxel data structure to locate and track voxels that satisfy particular property criteria, such as selection state, material type, or user-defined rules. It efficiently identifies and accesses relevant voxels to determine which voxels are currently subject to operations like highlighting, selection, or further processing.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ModelStructure} to get the model structure and data representation.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{MAX\_QUERY\_RESULTS}: int — maximum number of voxels returned in a single query result.
  \item \texttt{SUPPORTED\_PROPERTIES}: list[str] — list of property names that can be queried (e.g., "material", "magnetization", "selected", "layer").
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{p{4cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{queryByMaterial} & materialType: MaterialType & list[VoxelCoord] & InvalidMaterialError \\
\texttt{queryBySelection} & isSelected: bool & list[VoxelCoord] & None \\
\texttt{queryByRegion} & bounds: BoundingBox & list[VoxelCoord] & InvalidBoundsError \\
\texttt{queryByLayer} & layerZ: int & list[VoxelCoord] & IndexError \\
\texttt{queryByProperty} & propertyName: str, value: Any & list[VoxelCoord] & InvalidPropertyError \\
\texttt{getVoxelProperties} & coord: VoxelCoord & VoxelProperties & NotFoundError \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{queryCache}: dict[str] = list[VoxelCoord] — cached results of recent queries for performance optimization.
  \item \texttt{activeSelections}: set[VoxelCoord] — set of currently selected voxel coordinates.
\end{itemize}

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
\begin{itemize}
  \item Voxel coordinates provided in queries are within valid grid boundaries.
  \item Property names used in queries match those defined in \texttt{SUPPORTED\_PROPERTIES}.
  \item The voxel grid structure remains consistent during query operations.
\end{itemize}

\iffalse
\subsubsection{Access Routine Semantics}
\begin{itemize}
  \item \texttt{queryByMaterial(materialType)}: Returns all voxel coordinates that have the specified material type.
  \[
  R = \{v.coord \mid v \in G, v.material = materialType\}
  \]
  
  \item \texttt{queryBySelection(isSelected)}: Returns all voxel coordinates that match the selection state.
  \[
  R = \begin{cases}
  activeSelections & \text{if } isSelected = true\\
  \{v.coord \mid v \in G, v.coord \notin activeSelections\} & \text{if } isSelected = false
  \end{cases}
  \]
  
  \item \texttt{queryByRegion(bounds)}: Returns all voxel coordinates within the specified bounding box.
  \[
  R = \{v.coord = (x,y,z) \mid v \in G, bounds.min \leq (x,y,z) \leq bounds.max\}
  \]
  
  \item \texttt{queryByLayer(layerZ)}: Returns all voxel coordinates in the specified layer.
  \[
  R = \{v.coord = (x,y,z) \mid v \in G, z = layerZ\}
  \]
  
  \item \texttt{queryByProperty(propertyName, value)}: Returns all voxel coordinates where the specified property matches the given value.
  \[
  R = \{v.coord \mid v \in G, v[propertyName] = value\}
  \]
  
  \item \texttt{getVoxelProperties(coord)}: Retrieves all properties of the voxel at the specified coordinate.
  \[
  P = \{property: value \mid property \in SUPPORTED\_PROPERTIES, value = v[property]\}
  \]
  where $v$ is the voxel at coordinate $coord$.
\end{itemize}

\subsubsection{Exceptions}
\begin{itemize}
  \item \texttt{InvalidMaterialError} — material type not recognized or not in valid material set.
  \item \texttt{InvalidBoundsError} — bounding box is invalid (e.g., min > max) or out of grid boundaries.
  \item \texttt{IndexError} — layer index is out of range.
  \item \texttt{InvalidPropertyError} — property name not in \texttt{SUPPORTED\_PROPERTIES}.
  \item \texttt{NotFoundError} — voxel coordinate not present in grid.
\end{itemize}
\fi
\newpage

\section{MIS of Highlight Manager (M13)}\label{Module13} 

HighlightManager

\subsection{Module}
The HighlightManager module manages the voxel highlights in accordance with visual semantic meaning.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
  \item \texttt{DEFAULT\_HIGHLIGHT\_MAP}: dict[str] = str — mapping from semantic keys to their default highlight colours.
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{5cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline

\texttt{getHighlight} &
semanticKey: str &
ColourValue &
None \\

\texttt{editPalette} &
semanticKey: str, \newline
newColour: ColourValue &
void &
None \\

\texttt{setHighlight} &
semanticKey: str &
void &
None \\

\texttt{resetPalette} &
None &
void &
None \\

\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{highlightColourMap}: dict[str] = str — current mapping from semantic keys to active highlight colours.
\end{itemize}

\subsubsection{Environment Variables}
None


\subsubsection{Assumptions}
\begin{itemize}
  \item Semantic keys must correspond to valid entries maintained by the TrackingManager.
  \item Colour values are valid colour representations.
\end{itemize}

\newpage

\section{MIS of Export Validation (M14)}\label{Module14}

ExportValidation

\subsection{Module}

The ExportValidation module validates export readiness by checking export file format requirements, verifying completeness of voxel properties (material and magnetization), and ensuring all export constraints are met. 

\subsection{Uses}
\begin{itemize}
  \item \texttt{VoxelTracking} to get all the voxels in the model, ensure all voxels have material and magnetization properties.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
\item \texttt{MAX\_VOXELS}: $\mathbb{Z}$ = 13996800000 - Maximum number of voxels allowed
\item \texttt{MAX\_LAYERS}: $\mathbb{Z}$ = 518400 - Maximum number of layers allowed
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{5cm} p{5cm} p{3.5cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{validateExportReadiness} & model: ModelStructure & ValidationResult & - \\
\texttt{checkPrinterCompatibility} & model: ModelStructure & bool & - \\
\texttt{checkPropertyCompleteness} & model: ModelStructure & list[str] & - \\
\texttt{validateFileFormat} & filePath: str & bool & IOError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None

\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

\begin{itemize}
\item The model structure provided is valid and properly initialized
\item All voxels in the model have consistent property structures
\item File paths provided are accessible and readable
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
\item \texttt{countVoxels(model: ModelStructure) -> $\mathbb{Z}$}: Counts the total number of voxels in the model
\item \texttt{countLayers(model: ModelStructure) -> $\mathbb{Z}$}: Counts the total number of layers in the model
\item \texttt{checkPrinterSpecs(model: ModelStructure) -> bool}: Validates model against printer-specific constraints
\end{itemize}

\newpage

\section{MIS of Export Manager (M15)}\label{Module15} 

ExportManager

\subsection{Module}

The ExportManager module coordinates the export process, transforms internal model data into export-compatible formats, and serializes project data including voxel grids, metadata, material properties, and magnetization information according to export specifications.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ModelStructure} to obtain the model structure and data representation.
  \item \texttt{ExportValidation} to validate export validity.
  \item \texttt{ExportStructure} to define the export data structure format.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}


\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
\item \texttt{DEFAULT\_EXPORT\_FORMAT}: str = "CSV" - Default export file format
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{6cm} p{5cm} p{2cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{ExportManager} & - & self & - \\
\texttt{exportProject} & model: ModelStructure, \newline exportPath: str, \newline format: str & None &  IOError, \newline ValueError \\
\texttt{transformToExportFormat} & model: ModelStructure, \newline format: str & ExportData & - \\
\texttt{serializeData} & data: ExportData, \newline format: str & str & ValueError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
\item \texttt{exportFormat}: str - Current export format being used
\item \texttt{exportConfig}: dict - Configuration settings for export operations
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
\item \texttt{FILE\_SYSTEM}: The file system where export files are written
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
\item The model structure provided has been validated for export readiness
\item The export path directory exists or can be created
\item Write permissions are available for the export directory
\item The export format is supported
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
\item \texttt{groupVoxelsByLayer(model: ModelStructure) -> dict}: Groups voxels by their layer Z-coordinate
\item \texttt{encodeCSV(exportData: ExportData) -> str}: Encodes export data into CSV format string
\item \texttt{validateExportPath(path: str) -> bool}: Validates that the export path is writable
\item \texttt{creatExportDirectory(path: str) -> None}: Creates the export directory if it does not exist
\end{itemize}

\newpage

\section{MIS of Error Diagnostic Handler (M16)}\label{Module16}

ErrorDiagnosticHandler

\subsection{Module}

The ErrorDiagnosticHandler module detects, diagnoses, and handles errors that occur during model operations, graphics rendering, and file interactions. It provides error classification, logging, and recovery mechanisms to ensure system stability and user feedback.

\subsection{Uses}

None

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
\item \texttt{ERROR\_MODEL\_UNRESPONSIVE}: str = "MODEL\_UNRESPONSIVE" - Error code for unresponsive model
\item \texttt{ERROR\_GRAPHICS\_UPDATE}: str = "GRAPHICS\_UPDATE\_FAILURE" - Error code for graphics update failure
\item \texttt{ERROR\_FILE\_ISSUE}: str = "FILE\_OPERATION\_ERROR" - Error code for file operation errors
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{5cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{detectError} & errorContext: dict & ErrorDiagnostic & - \\
\texttt{classifyError} & errorCode: str, \newline errorContext: dict & ErrorType & - \\
\texttt{logError} & errorDiagnostic: ErrorDiagnostic & None & IOError \\
\texttt{handleErrorRecovery}& errorDiagnostic: ErrorDiagnostic & RecoveryAction & - \\
\texttt{getErrorSource} & errorDiagnostic: ErrorDiagnostic & str & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{errorLog}: list[ErrorDiagnostic] - History of detected errors
\item \texttt{errorPatterns}: dict - Patterns for error classification
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
\item \texttt{LOG\_FILE}: File system location for error logging
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
\item Error context dictionaries contain sufficient information for diagnosis
\item Log file location is writable
\item Error codes follow the defined constants
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
\item \texttt{analyzeErrorPattern(errorContext: dict) -> str}: Analyzes error context to identify error patterns
\item \texttt{determineErrorSource(context: dict) -> str}: Determines the source component from error context
\item \texttt{formatErrorMessage(errorCode: str, context: dict) -> str}: Formats a human-readable error message
\item \texttt{suggestRecoverySteps(errorType: ErrorType) -> list[str]}: Generates recovery step suggestions based on error type
\end{itemize}

\newpage


\section{MIS of Model Structure (M17)}\label{Module17}

ModelStructure

\subsection{Module}

The ModelStructure module stores and organizes all voxel and layer data for the model, including per-voxel properties, metadata, and structural dimensions.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
\item \texttt{VOXEL\_SIZE\_XY}: $\mathbb{R}$ = 300.0 - Voxel size in X and Y dimensions (micrometers)
\item \texttt{VOXEL\_SIZE\_Z}: $\mathbb{R}$ = 110.0 - Voxel size in Z dimension (micrometers)
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{5cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{ModelStructure} & dimensions: tuple[$\mathbb{Z}$, \newline $\mathbb{Z}$, $\mathbb{Z}$] & self & ValueError \\
\texttt{getVoxel} & position: tuple[$\mathbb{Z}$, \newline $\mathbb{Z}$, $\mathbb{Z}$] & Voxel & IndexError \\
\texttt{setVoxel} & position: tuple[$\mathbb{Z}$, \newline $\mathbb{Z}$, $\mathbb{Z}$], \newline voxel: Voxel & None & IndexError \\
\texttt{getLayer} & z: $\mathbb{Z}$ & Layer & IndexError \\
\texttt{getProperty} & position: tuple[$\mathbb{Z}$, \newline $\mathbb{Z}$, $\mathbb{Z}$], \newline propertyName: str & Any & IndexError, \newline KeyError \\
\texttt{setProperty} & position: tuple[$\mathbb{Z}$, \newline $\mathbb{Z}$, $\mathbb{Z}$], \newline propertyName: str, \newline value: Any & None & IndexError, \newline ValueError \\
\texttt{addLayer} & layer: Layer & None & ValueError \\
\texttt{getMetadata} & - & dict & - \\
\texttt{setMetadata} & key: str, \newline value: Any & None & - \\
\texttt{validateVoxel} & voxel: Voxel & bool & - \\
\texttt{hasMaterial} & voxel: Voxel & bool & - \\
\texttt{hasMagnetization} & voxel: Voxel & bool & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{voxelGrid}: 3D array[Voxel] - Three-dimensional grid storing voxel data
\item \texttt{layers}: list[Layer] - Ordered list of layers, indexed by Z-coordinate
\item \texttt{metadata}: dict - Dictionary containing model metadata (dimensions, material properties, etc.)
\item \texttt{dimensions}: tuple[$\mathbb{Z}$, $\mathbb{Z}$, $\mathbb{Z}$] - Grid dimensions (X, Y, Z)
\end{itemize}

\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

\begin{itemize}
\item Voxel positions are within the grid boundaries defined by \texttt{dimensions}
\item Layer ordering follows Z-axis ordering (bottom to top)
\item Property names are consistent across voxels
\item Material types and magnetization vectors conform to expected formats
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
\item \texttt{validatePosition(position: tuple[$\mathbb{Z}$, $\mathbb{Z}$, $\mathbb{Z}$]) -> bool}: Checks if position is within grid boundaries
\item \texttt{maintainLayerOrdering() -> None}: Ensures layers remain ordered by Z-coordinate
\item \texttt{createLayerFromZ(z: $\mathbb{Z}$) -> Layer}: Creates a new layer structure for a given Z-coordinate
\item \texttt{validatePropertyValue(propertyName: str, value: Any) -> bool}: Validates that a property value conforms to expected type and constraints
\end{itemize}

\newpage

\section{MIS of Graphics Adapter (M18)}\label{Module18}

GraphicsAdapter

\subsection{Module}
GraphicsAdapter handles all communication with the graphics API to enable visual rendering and generate a model on the UI.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item None
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{5cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{requestRender} & str: UpdateKey, \newline update: UpdateBundle & void & NetworkError \\
\texttt{getUpdateStatus} & str: UpdateKey & bool & None \\
\texttt{checkServerStatus} & None & Promise\textless void\textgreater & NetworkError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{updateStatus}: bool — tracks status of rendering completion.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
  \item \texttt{API\_BASE\_URL}: \textit{str} — external base URL for establishing environment configurations and enabling backend API requests.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
  \item Backend service is reachable and operational.
  \item Connection is available for API.
  \item Valid configurations exist for necessary API operations.
\end{itemize}


\newpage

\section{MIS of Database Handler (M19)}\label{Module19}

DatabaseHandler

\subsection{Module}
The DatabaseHandler module manages persistent storage for project and model data. It provides standardized interfaces for reading, writing, and deleting serialized model files, ensuring version integrity and consistent access to saved projects.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ModelStructure} to access model structures to keep track of the project.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{DEFAULT\_SAVE\_DIR}: str — default directory path for project files.
  \item \texttt{DB\_FORMAT\_VERSION}: str — current format version for data compatibility.
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{p{4cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \midrule
\texttt{saveProject} & id: str, data: SerializedModel & bool & IOError \\
\texttt{loadProject} & id: str & SerializedModel & FileNotFoundError \\
\texttt{deleteProject} & id: str & bool & IOError \\
\texttt{listProjects} & None & list[str] & None \\ \bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{projectMap}: dict[str] = SerializedModel — mapping of project identifiers to serialized data.
  \item \texttt{storagePath}: str — root directory for persistent project files.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
  \item \texttt{FILE\_SYSTEM}: OS-level file system used for reading/writing project data.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
  \item Project IDs are unique.
  \item File I/O operations succeed given sufficient permissions.
  \item SerializationManager ensures schema compatibility before writing data.
\end{itemize}

\newpage

\section{MIS of Export Structure (M20)}\label{Module20}

ExportStructure

\subsection{Module}
The ExportStructure module defines and implements the internal data structure for representing exported files, including field ordering, data types, and encoding format. It ensures consistency between internal model representations and external file layouts used during export operations.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \texttt{EXPORT\_SCHEMA\_VERSION}: str — current version of the export structure schema.
  \item \texttt{FIELD\_ORDER}: list[str] — ordered list of field names in export format: ["x", "y", "z", "layer", "materialId", "magnetizationX", "magnetizationY", "magnetizationZ"].
  \item \texttt{DEFAULT\_ENCODING}: str — default character encoding for export files (e.g., "UTF-8").
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{p{4cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{defineStructure} & format: str & ExportSchema & UnsupportedFormatError \\
\texttt{getFieldOrder} & format: str & list[str] & UnsupportedFormatError \\
\texttt{getFieldType} & fieldName: str & DataType & InvalidFieldError \\
\texttt{validateStructure} & data: ExportData & bool & StructureMismatchError \\
\texttt{createHeader} & metadata: dict & ExportHeader & None \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{exportSchema}: ExportSchema — current export structure schema definition.
  \item \texttt{fieldTypes}: dict[str] = DataType — mapping from field names to their data types.
\end{itemize}

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
\begin{itemize}
  \item Export format identifiers match supported formats ("CSV").
  \item Field names in export data match those defined in \texttt{FIELD\_ORDER}.
  \item Data types conform to the schema defined by \texttt{fieldTypes}.
  \item Export structure remains consistent across export operations.
\end{itemize}


\subsubsection{Local Functions}
\begin{itemize}
  \item \texttt{mapInternalToExport(internalData: VoxelData) -> ExportData}: Maps internal voxel representation to export format structure.
  \item \texttt{validateFieldValue(fieldName: str, value: Any) -> bool}: Validates that a field value matches its expected data type.
  \item \texttt{encodeFieldValue(fieldName: str, value: Any) -> str}: Encodes a field value according to the export format specification.
\end{itemize}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\iffalse
\section{Appendix}\label{Appendix}

\wss{Extra information if required}

\newpage{}



\wss{Not required for CAS 741 projects}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.
\fi

\section*{Appendix --- Reflection}

\input{../../Reflection.tex}

% \begin{enumerate}
%   \item What went well while writing this deliverable? 
%   \item What pain points did you experience during this deliverable, and how
%     did you resolve them?
%   \item Which of your design decisions stemmed from speaking to your client(s)
%   or a proxy (e.g. your peers, stakeholders, potential users)? For those that
%   were not, why, and where did they come from?
%   \item While creating the design doc, what parts of your other documents (e.g.
%   requirements, hazard analysis, etc), it any, needed to be changed, and why?
%   \item What are the limitations of your solution?  Put another way, given
%   unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)
%   \item Give a brief overview of other design solutions you considered.  What
%   are the benefits and tradeoffs of those other designs compared with the chosen
%   design?  From all the potential options, why did you select the documented design?
%   (LO\_Explores)
% \end{enumerate}

\subsubsection*{1. What went well while writing this deliverable?}
\bigskip\bigskip
\textbf{Omar: }
\newline
\newline
\textbf{Daniel: } 
\newline
\newline
\textbf{Andrew: } Integrating the UI and backend from Daniel went really well this deliverable. Working with him in unison was very helpful, and we got everything done in expert time.
\newline
\newline
\textbf{Olivia: }
\newline
\newline
\textbf{Khalid: } In terms of the code, the things that went well were the splitting the structure into multiple layers so they can be edited at the same time without interfering with each other. I was also able to find a way to convert the web application to a desktop application using Electron if needed.

\subsubsection*{2. What pain points did you experience during this deliverable, and how
did you resolve them?}
\bigskip
\textbf{Omar: }
\newline
\newline
\textbf{Daniel: } 
\newline
\newline
\textbf{Andrew: } I was part of the code team for this deliverable, so like Khalid - I did not have many point points regarding this MIS. Of my own exploration and work, I built the MVP UI and made sure to include an initial renderer, export and import manager using javascript frameworks and previous implementations of STL renderers. The pain point here was to find a suitable renderer and have it work in unison with our other modules, but it was not too much of a headache.
\newline
\newline
\textbf{Olivia: }
\newline
\newline
\textbf{Khalid: } I was part of the code team for this deliverable, so I didn't have any pain points regarding the document. However, in terms of the pain points I experienced for the code, I worked on the splitting the structure into multiple layers so they can be edited at the same time without interfering with each other. The pain point I had was finding an algorithm that will efficiently split the structure into multiple layers. I ended up using a simple algorithm that will split the structure into multiple layers based on the z-coordinate.

\subsubsection*{3. Which of your design decisions stemmed from speaking to your client(s)
or a proxy (e.g. your peers, stakeholders, potential users)? For those that
were not, why, and where did they come from?}

\subsubsection*{4. While creating the design doc, what parts of your other documents (e.g.
requirements, hazard analysis, etc), it any, needed to be changed, and why?}

\subsubsection*{5. What are the limitations of your solution?  Put another way, given
unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)}

\subsubsection*{6. Give a brief overview of other design solutions you considered.  What
are the benefits and tradeoffs of those other designs compared with the chosen
design?  From all the potential options, why did you select the documented design?
(LO\_Explores)}

\end{document}
