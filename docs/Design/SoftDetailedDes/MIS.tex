\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\newcommand{\mref}[1]{M\ref{#1}}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
November 13, 2025 & 1.0 & Initial draft by All\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See \href{https://github.com/OmarHassanAdelhamid/Five-of-a-Kind-capstone-project-/blob/main/docs/SRS-Meyer/requirements/SRS.pdf}{SRS} Documentation.

\iffalse
\wss{Also add any additional symbols, abbreviations or acronyms}
\fi

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for \progname{}. \progname{} is a desktop-based CAD enhancement tool that enables researchers and engineers to assign magnetic and material properties to individual voxels within a 3D model. The system allows users to import CAD files (STL format), automatically convert them into voxel grids, and interactively select and modify voxels layer by layer to assign magnetization directions and material assignments. This tool streamlines the magnetization planning process for multi-material 3D printing workflows in research laboratory environments.

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/OmarHassanAdelhamid/Five-of-a-Kind-capstone-project-}

\section{Notation}

\iffalse
\wss{You should describe your notation.  You can use what is below as
  a starting point.}
\fi

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
  \centering
  \begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
  \toprule
  \textbf{Level 1} & \textbf{Level 2}\\
  \midrule
  
  {Hardware-Hiding Module} & None \\
  \midrule
  
  \multirow{7}{0.3\textwidth}{Behaviour-Hiding Module} & Input Interpreter Module\\
  & Voxel Slicing Module\\
  & Display Partitioning Module\\
  & Project Manager Module\\
  & Serialization Manager Module\\
  & Backend Communication Manager Module\\
  & Interaction Controller Module\\
  & Visualization State Manager Module\\
  & Model Manager Module\\
  & History Manager Module\\
  & Autosave Manager Module\\
  & Voxel Tracking Module\\
  & Highlight Manager Module\\
  & Export Validation Module\\
  & Export Manager Module\\
  & Error Diagnostic Handler Module\\
  \midrule
  
  \multirow{3}{0.3\textwidth}{Software Decision Module} & Model Structure Module\\
  & Graphics Adapter Module\\
  & Database Handler Module\\
  & Export Structure Module\\
  \bottomrule
  
  \end{tabular}
  \caption{Module Hierarchy}
  \label{TblMH}
  \end{table}
\newpage
~\newpage

\section{MIS of Input Interpreter} \label{Module1} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

\wss{Short name for the module}

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}

\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\newpage

\section{MIS of Voxel Slicing} \label{Module2} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

\wss{Short name for the module}

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}

\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\newpage

\section{MIS of Display Partitioning} \label{Module3} 

DisplayPartitioning

\subsection{Module}
The DisplayPartitioning module provides core functionality for partitioning the model into distinct display segments.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ModelManager} to obtain the sliced model's data representation.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\noindent\textbf{Exported Constants}

\begin{itemize}
  \item \texttt{MAX\_PARTITION}: \textit{int} — maximum number of partitions that can be created.
  \item \texttt{MAX\_VOXEL\_PARTITION}: \textit{int} — maximum number of voxels per partition.
  \item \texttt{AVAILABLE\_PARTITIONS}: \textit{List[string]} — configuration of valid partition IDs used by the display layout.
\end{itemize}

\noindent\textbf{Exported Access Programs}:
\begin{center}
  \renewcommand{\arraystretch}{1.55}
  \begin{tabular}{p{4cm} p{5cm} p{3cm} p{3cm}}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
  \hline
  
  \texttt{getPartitions} &
  None &
  \textit{dict[string]} &
  None \\
  
  \texttt{setCurrentPartition} &
  id: \textit{string} \newline
  partition: \textit{PartitionItem} &
  void &
  None \\
  
  \texttt{resizePartitions} &
  id: \textit{string} \newline
  width: \textit{int} \newline
  height: \textit{int} \newline
  depth: \textit{int} &
  void &
  None \\
  
  \end{tabular}
  \end{center}
\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{PartitionItem}: \textit{record} — configuration for data that describes a partition.
  \item \texttt{PartitionDict}: \textit{dict[string] = PartitionItem} — tracks all partitions.
\end{itemize}

\subsubsection{Environment Variables}
None

  \subsubsection{Assumptions}
  \begin{itemize}
    \item A valid and complete \texttt{ModelStructure} exists.
    \item Display partitions adhere only to positive dimensions.
    \item \texttt{AVAILABLE\_PARTITIONS} provides the display layout with a preset mapping to UI grid positions.
  \end{itemize}
\newpage

\section{MIS of Project Manager} \label{Module4}

ProjectManager

\subsection{Module}

The ProjectManager module manages the creation, initialization, and persistence of project workspaces, handles project metadata storage, and ensures project resources are properly allocated.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ModelManager} to obtain and create the model structure and data representation.
  \item \texttt{DisplayPartitioning} to create and manage the display partitions.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

None

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{5cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
ProjectManager & - & self & IOError \\
create\_project & project\_path: str, \newline config: dict & None & \textbullet{} IOError \newline \textbullet{} ValueError \\
load\_project & project\_path: str & None & \textbullet{} IOError \newline \textbullet{} FileNotFoundError \\
save\_project & project\_path: str & None & IOError \\
get\_project\_metadata & - & dict & - \\
initialize\_workspace & workspace\_path: str & None & IOError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
\item \texttt{project\_path}: str - Path to the current project directory
\item \texttt{workspace\_root}: str - Root directory of the workspace
\item \texttt{project\_metadata}: dict - Dictionary containing project configuration and metadata
\item \texttt{model}: ModelStructure - Reference to the model structure instance
\item \texttt{is\_initialized}: bool - Flag indicating if the project has been initialized
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
\item \texttt{FILE\_SYSTEM}: The file system where project files are stored
\item \texttt{WORKSPACE\_ROOT}: Root directory environment variable for workspace location
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
\item The file system has sufficient space for project creation
\item The provided project path is a valid directory path
\item Write permissions are available for the project directory
\item The workspace root directory exists or can be created
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
\item \texttt{validate\_config(config: dict) -> bool}: Validates that the configuration dictionary contains required fields
\item \texttt{create\_project\_structure(path: str) -> None}: Creates the directory structure for a new project
\item \texttt{read\_metadata\_file(path: str) -> dict}: Reads and parses project metadata from file
\item \texttt{write\_metadata\_file(path: str, metadata: dict) -> None}: Writes project metadata to file
\end{itemize}

\newpage

\section{MIS of Serialization Manager} \label{Module5} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

\wss{Short name for the module}

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}

\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\newpage

\section{MIS of Backend Communication Manager} \label{Module6} 

BackendCommunicator
  
\subsection{Module}
The BackendCommunicator module manages the transfer and synchronization of data between the backend server and frontend UI.

\subsection{Uses}
\begin{itemize}
  \item \texttt{SerializationManager} for necessary JSON and binary transforms.
  \item \texttt{InteractionController} for processing raw UI information.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\noindent\textbf{Exported Constants}

\begin{itemize}
  \item None
\end{itemize}

\noindent\textbf{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{5cm} p{3cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline

\texttt{checkServerStatus} &
None &
Promise\textless void\textgreater&
Network Error \\

\texttt{initDataLogs} &
None &
Promise\textless boolean\textgreater &
Network Error \\

\texttt{getDataLogs} &
None &
string &
None \\

\texttt{getInteraction} &
None &
UIdata: string &
None \\

\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{serverStatus}: \textit{ServerStatusType} — tracks the current connection status of the backend server.
  \item \texttt{data\_log}: \textit{string} — all data gathered from the frontend that requires interpretation on the backend.
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item \texttt{SERVER\_URL}: \textit{string} — backend server URL from environment configuration.
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
  \item Backend service is reachable and operational.
  \item Connection is available for data synchronization.
  \item Valid configurations exist for necessary data transfer operations.
\end{itemize}


\newpage

\section{MIS of Interaction Controller} \label{Module7} 

InteractionController

\subsection{Module}
The InteractionController module manages the process of raw events from interaction with UI to associated actions within internal code.

\subsection{Uses}
\begin{itemize}
  \item \texttt{VisualizationManager} to establish current active view.
  \item \texttt{BackendCommunicationManager} for taking the collected raw UI data from the frontend and sending it for interpretation.
  \item \texttt{ModelManager} for handling user intent related to model modification.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\noindent\textbf{Exported Constants}

\begin{itemize}
  \item \texttt{UI\_EVENTS}: \textit{list[string]} — identifies all supported UI events that can be detected from user interaction.
  \item \texttt{UI\_ACTIONS}: \textit{list[string]} — identifies all supported interactions that can be derived from UI events.
\end{itemize}

\noindent\textbf{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{4cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline

\texttt{interpretEvent} &
UIdata: \textit{string} &
UIEvent &
None \\

\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{currentEvent}: \textit{UIEvent} — configuration for a UI event.
  \item \texttt{currentView}: \textit{string} — identifies what view is currently displayed during interaction.
  \item \texttt{pointerPosition}: \textit{[int, int]} — pointer coordinates captured from the most recent relevant event.
  \item \texttt{allEvents}: \textit{list[string]} — identifies all supported UI events that can be detected from user interaction.
\end{itemize}

\subsubsection{Environment Variables}
None


\subsubsection{Assumptions}
\begin{itemize}
  \item User intent does not exceed the scope of supported actions that can be derived.
  \item There can only be one current active view at a given moment.
  \item \texttt{pointerPosition} is contained within the screen resolution.
\end{itemize}

\newpage

\section{MIS of Visualization State Manager} \label{Module8} 

VisualizationManager

\subsection{Module}
The VisualizationManager module oversees the creation of UI views while managing subsequent updates to the display state of the specified current UI views on a backend level.

\subsection{Uses}
\begin{itemize}
  \item \texttt{DisplayPartitioning} for tracking different interface states across partitions.
  \item \texttt{GraphicsAdapter} for rendering updates visible to user.
  \item \texttt{ModelManager} for managing model and metadata updates that affect state visualization.
  \item \texttt{VoxelTrackingManager} for specifying the set of voxels affected by a given update.
  \item \texttt{HighlightManager} for managing change in voxels being highlighted.
  \item \texttt{HighlightManager} for managing change in voxels being highlighted.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\noindent\textbf{Exported Constants}

\begin{itemize}
  \item \texttt{DEFAULT\_VIEWS}: \textit{list[string]} — list of identifiers corresponding to the default views generated upon project initialization.
\end{itemize}

\noindent\textbf{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{6cm} p{3cm} p{2.5cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline

\texttt{getCurrentView} &
None &
ViewState &
None \\

\texttt{setView} &
state: \textit{ViewState} &
void &
None \\

\texttt{getHighlightState} &
None &
HighlightState &
None \\

\texttt{updateModel} &
voxelCoords: \textit{List[VoxelCoord]} \newline
updateType: \textit{ModelUpdateType} &
void &
None \\

\texttt{updateHighlight} &
semanticKey: \textit{string} &
void &
None \\

\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{currentView}: \textit{string} — identifies which UI view is currently shown to the user.
  \item \texttt{viewStatus}: \textit{dict[string] = ViewItem} — stores all data encapsulated within a UI view.
  \item \texttt{updateBundle}: \textit{dict[string] = UpdateItem} — stores all data needed to update a UI view upon a render request.
  \item \texttt{pendingUpdates}: \textit{list[UpdateKey]} — updates waiting to be processed in rendering.
  \item \texttt{renderStatus}: \textit{boolean} — records the success status of the rendering process.
  \item \texttt{supportedViews}: \textit{list[string]} — identifiers corresponding to all available project views.
\end{itemize}

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
\begin{itemize}
  \item Partitions are initialized.
  \item ViewItem is properly formatted in accordance with ViewItem specification.
  \item UpdateItem is properly formatted in accordance with UpdateItem specification.
  \item \texttt{currentView}, \texttt{ViewState}, and \texttt{DEFAULT\_VIEWS} are elements of \texttt{supportedViews}.
\end{itemize}

\newpage


\newpage

\section{MIS of Model Manager} \label{Module9} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

\wss{Short name for the module}

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}

\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\newpage

\section{MIS of History Manager} \label{Module10} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

\wss{Short name for the module}

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}

\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\newpage

\section{MIS of Autosave Manager} \label{Module11} 

AutosaveManager

\subsection{Module}
The AutosaveManager module prepares data to be saved, monitors when updates require saving, and invokes periodic scheduled transfers to file-based storage.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ModelManager} for tracking changes that require savings.
  \item \texttt{SerializationManager} for data preparation.
  \item \texttt{HistoryManager} for logging recent changes.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\noindent\textbf{Exported Constants}

\begin{itemize}
  \item \texttt{AUTOSAVE\_INTERVAL\_MS}: \textit{int} — minimum amount of time (in milliseconds) between autosave operations.
  \item \texttt{FILE\_ID}: \textit{string} — file to which autosave operations are written.
\end{itemize}

\noindent\textbf{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{3cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline

\texttt{forceSave} &
None &
None &
IO Error \\

\texttt{enableAutosave} &
None &
None &
None \\

\texttt{disableAutosave} &
None &
None &
None \\

\texttt{lastAutosaveTime} &
None &
DateTime &
None \\

\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{autosavePermission}: \textit{bool} — indicates whether autosave is enabled or disabled.
  \item \texttt{lastAutosave}: \textit{DateTime} — timestamp of last transfer to file-based storage.
  \item \texttt{autosaveHistory}: \textit{dict[DateTime] = Update} — complete log of transfers to file-based storage.
\end{itemize}


\subsubsection{Environment Variables}

\begin{itemize}
  \item \texttt{SYSTEM\_TIME}: \textit{DateTime} — global time supplied by the current system.
\end{itemize}


\subsubsection{Assumptions}
\begin{itemize}
  \item \texttt{SYSTEM\_TIME} always increases monotonically.
  \item Data preparation method is compatible with file-based storage.
  \item Connection is available to file-based storage.
  \item Valid configuration exists for operations to file-based storage.
\end{itemize}

\newpage

\section{MIS of Voxel Tracking} \label{Module12} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

\wss{Short name for the module}

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}

\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\newpage

\section{MIS of Highlight Manager} \label{Module13} 

HighlightManager

\subsection{Module}
The HighlightManager module manages the voxel highlights in accordance with visual semantic meaning.

\subsection{Uses}
\begin{itemize}
  \item \texttt{Visualization State Manager} for managing visual updates related to voxel highlights.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\noindent\textbf{Exported Constants}

\begin{itemize}
  \item \texttt{DEFAULT\_HIGHLIGHT\_MAP}: \textit{dict[string, string]} — mapping from semantic keys to their default highlight colours.
\end{itemize}

\noindent\textbf{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{5cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline

\texttt{getHighlight} &
semanticKey: \textit{string} &
ColourValue &
None \\

\texttt{editPalette} &
semanticKey: \textit{string} \newline
newColour: \textit{ColourValue} &
void &
None \\

\texttt{setHighlight} &
semanticKey: \textit{string} &
void &
None \\

\texttt{resetPalette} &
None &
void &
None \\

\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{highlightColourMap}: \textit{dict[string, string]} — current mapping from semantic keys to active highlight colours.
\end{itemize}

\subsubsection{Environment Variables}
None


\subsubsection{Assumptions}
\begin{itemize}
  \item Semantic keys must correspond to valid entries maintained by the TrackingManager.
  \item Colour values are valid colour representations.
\end{itemize}

\newpage

\section{MIS of Export Validation} \label{Module14}

ExportValidation

\subsection{Module}

The ExportValidation module validates export readiness by checking export file format requirements, verifying completeness of voxel properties (material and magnetization), and ensuring all export constraints are met. 

\subsection{Uses}
\begin{itemize}
  \item \texttt{ModelStructure} to obtain the model structure and data representation.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
\item \texttt{MAX\_VOXELS}: $\mathbb{Z}$ = 13996800000 - Maximum number of voxels allowed
\item \texttt{MAX\_LAYERS}: $\mathbb{Z}$ = 518400 - Maximum number of layers allowed
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{5cm} p{5cm} p{3.5cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
validate\_export\_readiness & model: ModelStructure & ValidationResult & - \\
check\_printer\_compatibility & model: ModelStructure & bool & - \\
check\_property\_completeness & model: ModelStructure & list[str] & - \\
validate\_file\_format & file\_path: str & bool & IOError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None

\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

\begin{itemize}
\item The model structure provided is valid and properly initialized
\item All voxels in the model have consistent property structures
\item File paths provided are accessible and readable
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
\item \texttt{count\_voxels(model: ModelStructure) -> $\mathbb{Z}$}: Counts the total number of voxels in the model
\item \texttt{count\_layers(model: ModelStructure) -> $\mathbb{Z}$}: Counts the total number of layers in the model
\item \texttt{check\_printer\_specs(model: ModelStructure) -> bool}: Validates model against printer-specific constraints
\end{itemize}

\newpage

\section{MIS of Export Manager} \label{Module15} 

ExportManager

\subsection{Module}

The ExportManager module coordinates the export process, transforms internal model data into export-compatible formats, and serializes project data including voxel grids, metadata, material properties, and magnetization information according to export specifications.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ModelStructure} to obtain the model structure and data representation.
  \item \texttt{ExportValidation} to get the export validation result.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}


\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
\item \texttt{DEFAULT\_EXPORT\_FORMAT}: str = "CSV" - Default export file format
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{6cm} p{5cm} p{2cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
ExportManager & - & self & - \\
export\_project & model: ModelStructure, \newline export\_path: str, \newline format: str & None & \textbullet{} IOError \newline \textbullet{} ValueError \\
transform\_to\_export\_format & model: ModelStructure, \newline format: str & ExportData & - \\
serialize\_data & data: ExportData, \newline format: str & str & ValueError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
\item \texttt{export\_format}: str - Current export format being used
\item \texttt{export\_config}: dict - Configuration settings for export operations
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
\item \texttt{FILE\_SYSTEM}: The file system where export files are written
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
\item The model structure provided has been validated for export readiness
\item The export path directory exists or can be created
\item Write permissions are available for the export directory
\item The export format is supported
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
\item \texttt{group\_voxels\_by\_layer(model: ModelStructure) -> dict}: Groups voxels by their layer Z-coordinate
\item \texttt{encode\_csv(export\_data: ExportData) -> str}: Encodes export data into CSV format string
\item \texttt{validate\_export\_path(path: str) -> bool}: Validates that the export path is writable
\item \texttt{create\_export\_directory(path: str) -> None}: Creates the export directory if it does not exist
\end{itemize}

\newpage

\section{MIS of Error Diagnostic Handler } \label{Module16}

ErrorDiagnosticHandler

\subsection{Module}

The ErrorDiagnosticHandler module detects, diagnoses, and handles errors that occur during model operations, graphics rendering, and file interactions. It provides error classification, logging, and recovery mechanisms to ensure system stability and user feedback.

\subsection{Uses}

None

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
\item \texttt{ERROR\_MODEL\_UNRESPONSIVE}: str = "MODEL\_UNRESPONSIVE" - Error code for unresponsive model
\item \texttt{ERROR\_GRAPHICS\_UPDATE}: str = "GRAPHICS\_UPDATE\_FAILURE" - Error code for graphics update failure
\item \texttt{ERROR\_FILE\_ISSUE}: str = "FILE\_OPERATION\_ERROR" - Error code for file operation errors
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{5cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
detect\_error & error\_context: dict & ErrorDiagnostic & - \\
classify\_error & error\_code: str, \newline error\_context: dict & ErrorType & - \\
log\_error & error\_diagnostic: ErrorDiagnostic & None & IOError \\
handle\_error\_recovery & error\_diagnostic: ErrorDiagnostic & RecoveryAction & - \\
get\_error\_source & error\_diagnostic: ErrorDiagnostic & str & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{error\_log}: list[ErrorDiagnostic] - History of detected errors
\item \texttt{error\_patterns}: dict - Patterns for error classification
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
\item \texttt{LOG\_FILE}: File system location for error logging
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
\item Error context dictionaries contain sufficient information for diagnosis
\item Log file location is writable
\item Error codes follow the defined constants
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
\item \texttt{analyze\_error\_pattern(error\_context: dict) -> str}: Analyzes error context to identify error patterns
\item \texttt{determine\_error\_source(context: dict) -> str}: Determines the source component from error context
\item \texttt{format\_error\_message(error\_code: str, context: dict) -> str}: Formats a human-readable error message
\item \texttt{suggest\_recovery\_steps(error\_type: ErrorType) -> list[str]}: Generates recovery step suggestions based on error type
\end{itemize}

\newpage


\section{MIS of Model Structure} \label{Module17}

ModelStructure

\subsection{Module}

The ModelStructure module stores and organizes all voxel and layer data for the model, including per-voxel properties, metadata, and structural dimensions.

\subsection{Uses}
\begin{itemize}
  \item \texttt{ModelManager} for managing the model structure and data representation.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
\item \texttt{VOXEL\_SIZE\_XY}: $\mathbb{R}$ = 300.0 - Voxel size in X and Y dimensions (micrometers)
\item \texttt{VOXEL\_SIZE\_Z}: $\mathbb{R}$ = 110.0 - Voxel size in Z dimension (micrometers)
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{5cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
ModelStructure & dimensions: tuple[$\mathbb{Z}$, \newline $\mathbb{Z}$, $\mathbb{Z}$] & self & ValueError \\
get\_voxel & position: tuple[$\mathbb{Z}$, \newline $\mathbb{Z}$, $\mathbb{Z}$] & Voxel & IndexError \\
set\_voxel & position: tuple[$\mathbb{Z}$, \newline $\mathbb{Z}$, $\mathbb{Z}$], \newline voxel: Voxel & None & IndexError \\
get\_layer & z: $\mathbb{Z}$ & Layer & IndexError \\
get\_property & position: tuple[$\mathbb{Z}$, \newline $\mathbb{Z}$, $\mathbb{Z}$], \newline property\_name: str & Any & \textbullet{} IndexError \newline \textbullet{} KeyError \\
set\_property & position: tuple[$\mathbb{Z}$, \newline $\mathbb{Z}$, $\mathbb{Z}$], \newline property\_name: str, \newline value: Any & None & \textbullet{} IndexError \newline \textbullet{} ValueError \\
add\_layer & layer: Layer & None & ValueError \\
get\_metadata & - & dict & - \\
set\_metadata & key: str, \newline value: Any & None & - \\
validate\_voxel & voxel: Voxel & bool & - \\
has\_material & voxel: Voxel & bool & - \\
has\_magnetization & voxel: Voxel & bool & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{voxel\_grid}: 3D array[Voxel] - Three-dimensional grid storing voxel data
\item \texttt{layers}: list[Layer] - Ordered list of layers, indexed by Z-coordinate
\item \texttt{metadata}: dict - Dictionary containing model metadata (dimensions, material properties, etc.)
\item \texttt{dimensions}: tuple[$\mathbb{Z}$, $\mathbb{Z}$, $\mathbb{Z}$] - Grid dimensions (X, Y, Z)
\end{itemize}

\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

\begin{itemize}
\item Voxel positions are within the grid boundaries defined by \texttt{dimensions}
\item Layer ordering follows Z-axis ordering (bottom to top)
\item Property names are consistent across voxels
\item Material types and magnetization vectors conform to expected formats
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
\item \texttt{validate\_position(position: tuple[$\mathbb{Z}$, $\mathbb{Z}$, $\mathbb{Z}$]) -> bool}: Checks if position is within grid boundaries
\item \texttt{maintain\_layer\_ordering() -> None}: Ensures layers remain ordered by Z-coordinate
\item \texttt{create\_layer\_from\_z(z: $\mathbb{Z}$) -> Layer}: Creates a new layer structure for a given Z-coordinate
\item \texttt{validate\_property\_value(property\_name: str, value: Any) -> bool}: Validates that a property value conforms to expected type and constraints
\end{itemize}

\newpage

\section{MIS of Graphics Adapter} \label{Module18} 

GraphicsAdapter

\subsection{Module}
GraphicsAdapter handles all communication with the graphics API to enable visual rendering and generate a model on the UI.

\subsection{Uses}
\begin{itemize}
  \item \texttt{VisualizationManager} aggregates necessary backend data and relays updates to the rendered view.
  \item \texttt{ErrorDiagnosticHandler} for error handling and diagnostics.
\end{itemize}

\subsection{Syntax}

\noindent\textbf{Exported Constants}

\begin{itemize}
  \item None
\end{itemize}

\noindent\textbf{Exported Access Programs}

\begin{center}
\renewcommand{\arraystretch}{1.55}
\begin{tabular}{p{4cm} p{5cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline

\texttt{requestRender} &
str: \textit{UpdateKey} \newline
update: \textit{UpdateBundle} &
void &
Network Error \\

\texttt{getUpdateStatus} &
str: \textit{UpdateKey} &
boolean &
None \\

\texttt{checkServerStatus} &
None &
Promise\textless void\textgreater &
Network Error \\

\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{updateStatus}: \textit{boolean} — tracks status of rendering completion.
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item \texttt{API\_BASE\_URL}: \textit{string} — external base URL for establishing environment configurations and enabling backend API requests.
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
  \item Backend service is reachable and operational.
  \item Connection is available for API.
  \item Valid configurations exist for necessary API operations.
\end{itemize}

\newpage

\section{MIS of Database Handler} \label{Module19} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

\wss{Short name for the module}

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}

\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\newpage

\section{MIS of Export Structure} \label{Module20} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

\wss{Short name for the module}

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}

\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\newpage{}

\section*{Appendix --- Reflection}

\wss{Not required for CAS 741 projects}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.

\input{../../Reflection.tex}

\begin{enumerate}
  \item What went well while writing this deliverable? 
  \item What pain points did you experience during this deliverable, and how
    did you resolve them?
  \item Which of your design decisions stemmed from speaking to your client(s)
  or a proxy (e.g. your peers, stakeholders, potential users)? For those that
  were not, why, and where did they come from?
  \item While creating the design doc, what parts of your other documents (e.g.
  requirements, hazard analysis, etc), it any, needed to be changed, and why?
  \item What are the limitations of your solution?  Put another way, given
  unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)
  \item Give a brief overview of other design solutions you considered.  What
  are the benefits and tradeoffs of those other designs compared with the chosen
  design?  From all the potential options, why did you select the documented design?
  (LO\_Explores)
\end{enumerate}


\end{document}
